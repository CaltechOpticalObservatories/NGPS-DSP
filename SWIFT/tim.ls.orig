Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 1



1                                 COMMENT *
2      
3                          This file is used to generate boot DSP code for the 250 MHz fiber optic
4                                  timing board using a DSP56303 as its main processor. It supports
5                                  split serial and frame transfer, but not split parallel nor binning.
6                                  *
7                                    PAGE    132                               ; Printronix page width - 132 columns
8      
9                          ; Include the boot and header files so addressing is easy
10                                   INCLUDE "timhdr.asm"
11                                COMMENT *
12     
13                         This is a header file that is shared between the fiber optic timing board
14                         boot and application code files for Rev. 5 = 250 MHz timing boards
15                                 *
16     
17                                   PAGE    132                               ; Printronix page width - 132 columns
18     
19                         ; Various addressing control registers
20        FFFFFB           BCR       EQU     $FFFFFB                           ; Bus Control Register
21        FFFFF9           AAR0      EQU     $FFFFF9                           ; Address Attribute Register, channel 0
22        FFFFF8           AAR1      EQU     $FFFFF8                           ; Address Attribute Register, channel 1
23        FFFFF7           AAR2      EQU     $FFFFF7                           ; Address Attribute Register, channel 2
24        FFFFF6           AAR3      EQU     $FFFFF6                           ; Address Attribute Register, channel 3
25        FFFFFD           PCTL      EQU     $FFFFFD                           ; PLL control register
26        FFFFFE           IPRP      EQU     $FFFFFE                           ; Interrupt Priority register - Peripheral
27        FFFFFF           IPRC      EQU     $FFFFFF                           ; Interrupt Priority register - Core
28     
29                         ; Port E is the Synchronous Communications Interface (SCI) port
30        FFFF9F           PCRE      EQU     $FFFF9F                           ; Port Control Register
31        FFFF9E           PRRE      EQU     $FFFF9E                           ; Port Direction Register
32        FFFF9D           PDRE      EQU     $FFFF9D                           ; Port Data Register
33        FFFF9C           SCR       EQU     $FFFF9C                           ; SCI Control Register
34        FFFF9B           SCCR      EQU     $FFFF9B                           ; SCI Clock Control Register
35     
36        FFFF9A           SRXH      EQU     $FFFF9A                           ; SCI Receive Data Register, High byte
37        FFFF99           SRXM      EQU     $FFFF99                           ; SCI Receive Data Register, Middle byte
38        FFFF98           SRXL      EQU     $FFFF98                           ; SCI Receive Data Register, Low byte
39     
40        FFFF97           STXH      EQU     $FFFF97                           ; SCI Transmit Data register, High byte
41        FFFF96           STXM      EQU     $FFFF96                           ; SCI Transmit Data register, Middle byte
42        FFFF95           STXL      EQU     $FFFF95                           ; SCI Transmit Data register, Low byte
43     
44        FFFF94           STXA      EQU     $FFFF94                           ; SCI Transmit Address Register
45        FFFF93           SSR       EQU     $FFFF93                           ; SCI Status Register
46     
47        000009           SCITE     EQU     9                                 ; X:SCR bit set to enable the SCI transmitter
48        000008           SCIRE     EQU     8                                 ; X:SCR bit set to enable the SCI receiver
49        000000           TRNE      EQU     0                                 ; This is set in X:SSR when the transmitter
50                                                                             ;  shift and data registers are both empty
51        000001           TDRE      EQU     1                                 ; This is set in X:SSR when the transmitter
52                                                                             ;  data register is empty
53        000002           RDRF      EQU     2                                 ; X:SSR bit set when receiver register is full
54        00000F           SELSCI    EQU     15                                ; 1 for SCI to backplane, 0 to front connector
55     
56     
57                         ; ESSI Flags
58        000006           TDE       EQU     6                                 ; Set when transmitter data register is empty
59        000007           RDF       EQU     7                                 ; Set when receiver is full of data
60        000010           TE        EQU     16                                ; Transmitter enable
61     
62                         ; Phase Locked Loop initialization
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timhdr.asm  Page 2



63        050003           PLL_INIT  EQU     $050003                           ; PLL = 25 MHz x 2 = 100 MHz
64     
65                         ; Port B general purpose I/O
66        FFFFC4           HPCR      EQU     $FFFFC4                           ; Control register (bits 1-6 cleared for GPIO)
67        FFFFC9           HDR       EQU     $FFFFC9                           ; Data register
68        FFFFC8           HDDR      EQU     $FFFFC8                           ; Data Direction Register bits (=1 for output)
69     
70                         ; Port C is Enhanced Synchronous Serial Port 0 = ESSI0
71        FFFFBF           PCRC      EQU     $FFFFBF                           ; Port C Control Register
72        FFFFBE           PRRC      EQU     $FFFFBE                           ; Port C Data direction Register
73        FFFFBD           PDRC      EQU     $FFFFBD                           ; Port C GPIO Data Register
74        FFFFBC           TX00      EQU     $FFFFBC                           ; Transmit Data Register #0
75        FFFFB8           RX0       EQU     $FFFFB8                           ; Receive data register
76        FFFFB7           SSISR0    EQU     $FFFFB7                           ; Status Register
77        FFFFB6           CRB0      EQU     $FFFFB6                           ; Control Register B
78        FFFFB5           CRA0      EQU     $FFFFB5                           ; Control Register A
79     
80                         ; Port D is Enhanced Synchronous Serial Port 1 = ESSI1
81        FFFFAF           PCRD      EQU     $FFFFAF                           ; Port D Control Register
82        FFFFAE           PRRD      EQU     $FFFFAE                           ; Port D Data direction Register
83        FFFFAD           PDRD      EQU     $FFFFAD                           ; Port D GPIO Data Register
84        FFFFAC           TX10      EQU     $FFFFAC                           ; Transmit Data Register 0
85        FFFFA7           SSISR1    EQU     $FFFFA7                           ; Status Register
86        FFFFA6           CRB1      EQU     $FFFFA6                           ; Control Register B
87        FFFFA5           CRA1      EQU     $FFFFA5                           ; Control Register A
88     
89                         ; Timer module addresses
90        FFFF8F           TCSR0     EQU     $FFFF8F                           ; Timer control and status register
91        FFFF8E           TLR0      EQU     $FFFF8E                           ; Timer load register = 0
92        FFFF8D           TCPR0     EQU     $FFFF8D                           ; Timer compare register = exposure time
93        FFFF8C           TCR0      EQU     $FFFF8C                           ; Timer count register = elapsed time
94        FFFF83           TPLR      EQU     $FFFF83                           ; Timer prescaler load register => milliseconds
95        FFFF82           TPCR      EQU     $FFFF82                           ; Timer prescaler count register
96        000000           TIM_BIT   EQU     0                                 ; Set to enable the timer
97        000009           TRM       EQU     9                                 ; Set to enable the timer preloading
98        000015           TCF       EQU     21                                ; Set when timer counter = compare register
99     
100                        ; Board specific addresses and constants
101       FFFFF1           RDFO      EQU     $FFFFF1                           ; Read incoming fiber optic data byte
102       FFFFF2           WRFO      EQU     $FFFFF2                           ; Write fiber optic data replies
103       FFFFF3           WRSS      EQU     $FFFFF3                           ; Write switch state
104       FFFFF5           WRLATCH   EQU     $FFFFF5                           ; Write to a latch
105       010000           RDAD      EQU     $010000                           ; Read A/D values into the DSP
106       000009           EF        EQU     9                                 ; Serial receiver empty flag
107    
108                        ; DSP port A bit equates
109       000000           PWROK     EQU     0                                 ; Power control board says power is OK
110       000001           LED1      EQU     1                                 ; Control one of two LEDs
111       000002           LVEN      EQU     2                                 ; Low voltage power enable
112       000003           HVEN      EQU     3                                 ; High voltage power enable
113       00000E           SSFHF     EQU     14                                ; Switch state FIFO half full flag
114       00000A           EXT_IN0   EQU     10                                ; External digital I/O to the timing board
115       00000B           EXT_IN1   EQU     11
116       00000C           EXT_OUT0  EQU     12
117       00000D           EXT_OUT1  EQU     13
118    
119                        ; Port D equate
120       000001           SSFEF     EQU     1                                 ; Switch state FIFO empty flag
121    
122                        ; Other equates
123       000002           WRENA     EQU     2                                 ; Enable writing to the EEPROM
124    
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timhdr.asm  Page 3



125                        ; Latch U25 bit equates
126       000000           CDAC      EQU     0                                 ; Clear the analog board DACs
127       000002           ENCK      EQU     2                                 ; Enable the clock outputs
128       000004           SHUTTER   EQU     4                                 ; Control the shutter
129       000005           TIM_U_RST EQU     5                                 ; Reset the utility board
130    
131                        ; Software status bits, defined at X:<STATUS = X:0
132       000000           ST_RCV    EQU     0                                 ; Set to indicate word is from SCI = utility board
133       000002           IDLMODE   EQU     2                                 ; Set if need to idle after readout
134       000003           ST_SHUT   EQU     3                                 ; Set to indicate shutter is closed, clear for open
135       000004           ST_RDC    EQU     4                                 ; Set if executing 'RDC' command - reading out
136       000005           SPLIT_S   EQU     5                                 ; Set if split serial
137       000006           SPLIT_P   EQU     6                                 ; Set if split parallel
138       000007           MPP       EQU     7                                 ; Set if parallels are in MPP mode
139       000008           NOT_CLR   EQU     8                                 ; Set if not to clear CCD before exposure
140       00000A           TST_IMG   EQU     10                                ; Set if controller is to generate a test image
141       00000B           SHUT      EQU     11                                ; Set if opening shutter at beginning of exposure
142       00000C           ST_DITH   EQU     12                                ; Set if to dither during exposure
143       00000D           ST_SYNC   EQU     13                                ; Set if starting exposure on SYNC = high signal
144                        ;ST_CNRD        EQU     14      ; Set if in continous readout mode
145                        ; didn't need to commenct out above as we have a 24-bit status word...
146       00000E           POWERST   EQU     14                                ; current power state
147    
148                        ; Address for the table containing the incoming SCI words
149       000400           SCI_TABLE EQU     $400
150    
151    
152                        ; Specify controller configuration bits of the X:STATUS word
153                        ;   to describe the software capabilities of this application file
154                        ; The bit is set (=1) if the capability is supported by the controller
155    
156    
157                                COMMENT *
158    
159                        BIT #'s         FUNCTION
160                        2,1,0           Video Processor
161                                                000     CCD Rev. 3
162                                                001     CCD Gen I
163                                                010     IR Rev. 4
164                                                011     IR Coadder
165                                                100     CCD Rev. 5, Differential input
166                                                101     8x IR
167    
168                        4,3             Timing Board
169                                                00      Rev. 4, Gen II
170                                                01      Gen I
171                                                10      Rev. 5, Gen III, 250 MHz
172    
173                        6,5             Utility Board
174                                                00      No utility board
175                                                01      Utility Rev. 3
176    
177                        7               Shutter
178                                                0       No shutter support
179                                                1       Yes shutter support
180    
181                        9,8             Temperature readout
182                                                00      No temperature readout
183                                                01      Polynomial Diode calibration
184                                                10      Linear temperature sensor calibration
185    
186                        10              Subarray readout
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timhdr.asm  Page 4



187                                                0       Not supported
188                                                1       Yes supported
189    
190                        11              Binning
191                                                0       Not supported
192                                                1       Yes supported
193    
194                        12              Split-Serial readout
195                                                0       Not supported
196                                                1       Yes supported
197    
198                        13              Split-Parallel readout
199                                                0       Not supported
200                                                1       Yes supported
201    
202                        14              MPP = Inverted parallel clocks
203                                                0       Not supported
204                                                1       Yes supported
205    
206                        16,15           Clock Driver Board
207                                                00      Rev. 3
208                                                11      No clock driver board (Gen I)
209    
210                        19,18,17                Special implementations
211                                                000     Somewhere else
212                                                001     Mount Laguna Observatory
213                                                010     NGST Aladdin
214                                                xxx     Other
215                                *
216    
217                        CCDVIDREV3B
218       000000                     EQU     $000000                           ; CCD Video Processor Rev. 3
219       000001           VIDGENI   EQU     $000001                           ; CCD Video Processor Gen I
220       000002           IRREV4    EQU     $000002                           ; IR Video Processor Rev. 4
221       000003           COADDER   EQU     $000003                           ; IR Coadder
222       000004           CCDVIDREV5 EQU    $000004                           ; Differential input CCD video Rev. 5
223       000000           TIMREV4   EQU     $000000                           ; Timing Revision 4 = 50 MHz
224       000008           TIMGENI   EQU     $000008                           ; Timing Gen I = 40 MHz
225       000010           TIMREV5   EQU     $000010                           ; Timing Revision 5 = 250 MHz
226       000020           UTILREV3  EQU     $000020                           ; Utility Rev. 3 supported
227       000080           SHUTTER_CC EQU    $000080                           ; Shutter supported
228       000100           TEMP_POLY EQU     $000100                           ; Polynomial calibration
229                        TEMP_LINEAR
230       000200                     EQU     $000200                           ; Linear calibration
231       000400           SUBARRAY  EQU     $000400                           ; Subarray readout supported
232       000800           BINNING   EQU     $000800                           ; Binning supported
233                        SPLIT_SERIAL
234       001000                     EQU     $001000                           ; Split serial supported
235                        SPLIT_PARALLEL
236       002000                     EQU     $002000                           ; Split parallel supported
237       004000           MPP_CC    EQU     $004000                           ; Inverted clocks supported
238       018000           CLKDRVGENI EQU    $018000                           ; No clock driver board - Gen I
239       020000           MLO       EQU     $020000                           ; Set if Mount Laguna Observatory
240       040000           NGST      EQU     $040000                           ; NGST Aladdin implementation
241       100000           CONT_RD   EQU     $100000                           ; Continuous readout implemented
242    
243                                  INCLUDE "timboot.asm"
244                               COMMENT *
245    
246                        This file is used to generate boot DSP code for the 250 MHz fiber optic
247                                timing board using a DSP56303 as its main processor.
248                        Added utility board support Dec. 2002
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 5



249                                *
250                                  PAGE    132                               ; Printronix page width - 132 columns
251    
252                        ; Special address for two words for the DSP to bootstrap code from the EEPROM
253                                  IF      @SCP("HOST","ROM")
260                                  ENDIF
261    
262                                  IF      @SCP("HOST","HOST")
263       P:000000 P:000000                   ORG     P:0,P:0
264       P:000000 P:000000 0C0190            JMP     <INIT
265       P:000001 P:000001 000000            NOP
266                                           ENDIF
267    
268                                 ;  This ISR receives serial words a byte at a time over the asynchronous
269                                 ;    serial link (SCI) and squashes them into a single 24-bit word
270       P:000002 P:000002 602400  SCI_RCV   MOVE              R0,X:<SAVE_R0           ; Save R0
271       P:000003 P:000003 052139            MOVEC             SR,X:<SAVE_SR           ; Save Status Register
272       P:000004 P:000004 60A700            MOVE              X:<SCI_R0,R0            ; Restore R0 = pointer to SCI receive regist
er
273       P:000005 P:000005 542300            MOVE              A1,X:<SAVE_A1           ; Save A1
274       P:000006 P:000006 452200            MOVE              X1,X:<SAVE_X1           ; Save X1
275       P:000007 P:000007 54A600            MOVE              X:<SCI_A1,A1            ; Get SRX value of accumulator contents
276       P:000008 P:000008 45E000            MOVE              X:(R0),X1               ; Get the SCI byte
277       P:000009 P:000009 0AD041            BCLR    #1,R0                             ; Test for the address being $FFF6 = last by
te
278       P:00000A P:00000A 000000            NOP
279       P:00000B P:00000B 000000            NOP
280       P:00000C P:00000C 000000            NOP
281       P:00000D P:00000D 205862            OR      X1,A      (R0)+                   ; Add the byte into the 24-bit word
282       P:00000E P:00000E 0E0013            JCC     <MID_BYT                          ; Not the last byte => only restore register
s
283       P:00000F P:00000F 545C00  END_BYT   MOVE              A1,X:(R4)+              ; Put the 24-bit word into the SCI buffer
284       P:000010 P:000010 60F400            MOVE              #SRXL,R0                ; Re-establish first address of SCI interfac
e
                            FFFF98
285       P:000012 P:000012 2C0000            MOVE              #0,A1                   ; For zeroing out SCI_A1
286       P:000013 P:000013 602700  MID_BYT   MOVE              R0,X:<SCI_R0            ; Save the SCI receiver address
287       P:000014 P:000014 542600            MOVE              A1,X:<SCI_A1            ; Save A1 for next interrupt
288       P:000015 P:000015 05A139            MOVEC             X:<SAVE_SR,SR           ; Restore Status Register
289       P:000016 P:000016 54A300            MOVE              X:<SAVE_A1,A1           ; Restore A1
290       P:000017 P:000017 45A200            MOVE              X:<SAVE_X1,X1           ; Restore X1
291       P:000018 P:000018 60A400            MOVE              X:<SAVE_R0,R0           ; Restore R0
292       P:000019 P:000019 000004            RTI                                       ; Return from interrupt service
293    
294                                 ; Clear error condition and interrupt on SCI receiver
295       P:00001A P:00001A 077013  CLR_ERR   MOVEP             X:SSR,X:RCV_ERR         ; Read SCI status register
                            000025
296       P:00001C P:00001C 077018            MOVEP             X:SRXL,X:RCV_ERR        ; This clears any error
                            000025
297       P:00001E P:00001E 000004            RTI
298    
299       P:00001F P:00001F                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
300       P:000030 P:000030                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
301       P:000040 P:000040                   DC      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
302    
303                                 ;Tune the table so the following instruction is at P:$50 exactly.
304       P:000050 P:000050 0D0002            JSR     SCI_RCV                           ; SCI receive data interrupt
305       P:000051 P:000051 000000            NOP
306       P:000052 P:000052 0D001A            JSR     CLR_ERR                           ; SCI receive error interrupt
307       P:000053 P:000053 000000            NOP
308    
309                                 ; *******************  Command Processing  ******************
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 6



310    
311                                 ; Read the header and check it for self-consistency
312       P:000054 P:000054 609F00  START     MOVE              X:<IDL_ADR,R0
313       P:000055 P:000055 018FA0            JSET    #TIM_BIT,X:TCSR0,EXPOSING         ; If exposing go check the timer
                            00037C
314       P:000057 P:000057 0A00A4            JSET    #ST_RDC,X:<STATUS,CONTINUE_READING
                            100000
315       P:000059 P:000059 0AE080            JMP     (R0)
316    
317       P:00005A P:00005A 330700  TST_RCV   MOVE              #<COM_BUF,R3
318       P:00005B P:00005B 0D00A5            JSR     <GET_RCV
319       P:00005C P:00005C 0E005B            JCC     *-1
320    
321                                 ; Check the header and read all the remaining words in the command
322       P:00005D P:00005D 0C00FF  PRC_RCV   JMP     <CHK_HDR                          ; Update HEADER and NWORDS
323       P:00005E P:00005E 578600  PR_RCV    MOVE              X:<NWORDS,B             ; Read this many words total in the command
324       P:00005F P:00005F 000000            NOP
325       P:000060 P:000060 01418C            SUB     #1,B                              ; We've already read the header
326       P:000061 P:000061 000000            NOP
327       P:000062 P:000062 06CF00            DO      B,RD_COM
                            00006A
328       P:000064 P:000064 205B00            MOVE              (R3)+                   ; Increment past what's been read already
329       P:000065 P:000065 0B0080  GET_WRD   JSCLR   #ST_RCV,X:STATUS,CHK_FO
                            0000A9
330       P:000067 P:000067 0B00A0            JSSET   #ST_RCV,X:STATUS,CHK_SCI
                            0000D5
331       P:000069 P:000069 0E0065            JCC     <GET_WRD
332       P:00006A P:00006A 000000            NOP
333       P:00006B P:00006B 330700  RD_COM    MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
334    
335                                 ; Is this command for the timing board?
336       P:00006C P:00006C 448500            MOVE              X:<HEADER,X0
337       P:00006D P:00006D 579B00            MOVE              X:<DMASK,B
338       P:00006E P:00006E 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
339       P:00006F P:00006F 20006D            CMP     X1,B                              ; Does header = timing board number?
340       P:000070 P:000070 0EA080            JEQ     <COMMAND                          ; Yes, process it here
341       P:000071 P:000071 0E909D            JLT     <FO_XMT                           ; Send it to fiber optic transmitter
342    
343                                 ; Transmit the command to the utility board over the SCI port
344       P:000072 P:000072 060600            DO      X:<NWORDS,DON_XMT                 ; Transmit NWORDS
                            00007E
345       P:000074 P:000074 60F400            MOVE              #STXL,R0                ; SCI first byte address
                            FFFF95
346       P:000076 P:000076 44DB00            MOVE              X:(R3)+,X0              ; Get the 24-bit word to transmit
347       P:000077 P:000077 060380            DO      #3,SCI_SPT
                            00007D
348       P:000079 P:000079 019381            JCLR    #TDRE,X:SSR,*                     ; Continue ONLY if SCI XMT is empty
                            000079
349       P:00007B P:00007B 445800            MOVE              X0,X:(R0)+              ; Write to SCI, byte pointer + 1
350       P:00007C P:00007C 000000            NOP                                       ; Delay for the status flag to be set
351       P:00007D P:00007D 000000            NOP
352                                 SCI_SPT
353       P:00007E P:00007E 000000            NOP
354                                 DON_XMT
355       P:00007F P:00007F 0C0054            JMP     <START
356    
357                                 ; Process the receiver entry - is it in the command table ?
358       P:000080 P:000080 0203DF  COMMAND   MOVE              X:(R3+1),B              ; Get the command
359       P:000081 P:000081 205B00            MOVE              (R3)+
360       P:000082 P:000082 205B00            MOVE              (R3)+                   ; Point R3 to the first argument
361       P:000083 P:000083 302800            MOVE              #<COM_TBL,R0            ; Get the command table starting address
362       P:000084 P:000084 062380            DO      #NUM_COM,END_COM                  ; Loop over the command table
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 7



                            00008B
363       P:000086 P:000086 47D800            MOVE              X:(R0)+,Y1              ; Get the command table entry
364       P:000087 P:000087 62E07D            CMP     Y1,B      X:(R0),R2               ; Does receiver = table entries address?
365       P:000088 P:000088 0E208B            JNE     <NOT_COM                          ; No, keep looping
366       P:000089 P:000089 00008C            ENDDO                                     ; Restore the DO loop system registers
367       P:00008A P:00008A 0AE280            JMP     (R2)                              ; Jump execution to the command
368       P:00008B P:00008B 205800  NOT_COM   MOVE              (R0)+                   ; Increment the register past the table addr
ess
369                                 END_COM
370       P:00008C P:00008C 0C008D            JMP     <ERROR                            ; The command is not in the table
371    
372                                 ; It's not in the command table - send an error message
373       P:00008D P:00008D 479D00  ERROR     MOVE              X:<ERR,Y1               ; Send the message - there was an error
374       P:00008E P:00008E 0C0090            JMP     <FINISH1                          ; This protects against unknown commands
375    
376                                 ; Send a reply packet - header and reply
377       P:00008F P:00008F 479800  FINISH    MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
378    
379       P:000090 P:000090 578500  FINISH1   MOVE              X:<HEADER,B             ; Get header of incoming command
380       P:000091 P:000091 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
381       P:000092 P:000092 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
382       P:000093 P:000093 46935E            AND     Y0,B      X:<TWO,Y0
383       P:000094 P:000094 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
384       P:000095 P:000095 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
385       P:000096 P:000096 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
386       P:000097 P:000097 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
387       P:000098 P:000098 000000            NOP
388       P:000099 P:000099 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
389       P:00009A P:00009A 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
390       P:00009B P:00009B 570500            MOVE              B,X:<HEADER
391       P:00009C P:00009C 0C006B            JMP     <RD_COM                           ; Decide where to send the reply, and do it
392    
393                                 ; Transmit words to the host computer over the fiber optics link
394       P:00009D P:00009D 63F400  FO_XMT    MOVE              #COM_BUF,R3
                            000007
395       P:00009F P:00009F 060600            DO      X:<NWORDS,DON_FFO                 ; Transmit all the words in the command
                            0000A3
396       P:0000A1 P:0000A1 57DB00            MOVE              X:(R3)+,B
397       P:0000A2 P:0000A2 0D00EB            JSR     <XMT_WRD
398       P:0000A3 P:0000A3 000000            NOP
399       P:0000A4 P:0000A4 0C0054  DON_FFO   JMP     <START
400    
401                                 ; Check for commands from the fiber optic FIFO and the utility board (SCI)
402       P:0000A5 P:0000A5 0D00A9  GET_RCV   JSR     <CHK_FO                           ; Check for fiber optic command from FIFO
403       P:0000A6 P:0000A6 0E80A8            JCS     <RCV_RTS                          ; If there's a command, check the header
404       P:0000A7 P:0000A7 0D00D5            JSR     <CHK_SCI                          ; Check for an SCI command
405       P:0000A8 P:0000A8 00000C  RCV_RTS   RTS
406    
407                                 ; Because of FIFO metastability require that EF be stable for two tests
408       P:0000A9 P:0000A9 0A8989  CHK_FO    JCLR    #EF,X:HDR,TST2                    ; EF = Low,  Low  => CLR SR, return
                            0000AC
409       P:0000AB P:0000AB 0C00AF            JMP     <TST3                             ;      High, Low  => try again
410       P:0000AC P:0000AC 0A8989  TST2      JCLR    #EF,X:HDR,CLR_CC                  ;      Low,  High => try again
                            0000D1
411       P:0000AE P:0000AE 0C00A9            JMP     <CHK_FO                           ;      High, High => read FIFO
412       P:0000AF P:0000AF 0A8989  TST3      JCLR    #EF,X:HDR,CHK_FO
                            0000A9
413    
414       P:0000B1 P:0000B1 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 8



415       P:0000B3 P:0000B3 000000            NOP
416       P:0000B4 P:0000B4 000000            NOP
417       P:0000B5 P:0000B5 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
418       P:0000B7 P:0000B7 2B0000            MOVE              #0,B2
419       P:0000B8 P:0000B8 0140CE            AND     #$FF,B
                            0000FF
420       P:0000BA P:0000BA 0140CD            CMP     #>$AC,B                           ; It must be $AC to be a valid word
                            0000AC
421       P:0000BC P:0000BC 0E20D1            JNE     <CLR_CC
422       P:0000BD P:0000BD 4EF000            MOVE                          Y:RDFO,Y0   ; Read the MS byte
                            FFFFF1
423       P:0000BF P:0000BF 0C1951            INSERT  #$008010,Y0,B
                            008010
424       P:0000C1 P:0000C1 4EF000            MOVE                          Y:RDFO,Y0   ; Read the middle byte
                            FFFFF1
425       P:0000C3 P:0000C3 0C1951            INSERT  #$008008,Y0,B
                            008008
426       P:0000C5 P:0000C5 4EF000            MOVE                          Y:RDFO,Y0   ; Read the LS byte
                            FFFFF1
427       P:0000C7 P:0000C7 0C1951            INSERT  #$008000,Y0,B
                            008000
428       P:0000C9 P:0000C9 000000            NOP
429       P:0000CA P:0000CA 516300            MOVE              B0,X:(R3)               ; Put the word into COM_BUF
430       P:0000CB P:0000CB 0A0000            BCLR    #ST_RCV,X:<STATUS                 ; Its a command from the host computer
431       P:0000CC P:0000CC 000000  SET_CC    NOP
432       P:0000CD P:0000CD 0AF960            BSET    #0,SR                             ; Valid word => SR carry bit = 1
433       P:0000CE P:0000CE 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
434       P:0000D0 P:0000D0 00000C            RTS
435       P:0000D1 P:0000D1 0AF940  CLR_CC    BCLR    #0,SR                             ; Not valid word => SR carry bit = 0
436       P:0000D2 P:0000D2 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
437       P:0000D4 P:0000D4 00000C            RTS
438    
439                                 ; Test the SCI (= synchronous communications interface) for new words
440       P:0000D5 P:0000D5 44F000  CHK_SCI   MOVE              X:(SCI_TABLE+33),X0
                            000421
441       P:0000D7 P:0000D7 228E00            MOVE              R4,A
442       P:0000D8 P:0000D8 209000            MOVE              X0,R0
443       P:0000D9 P:0000D9 200045            CMP     X0,A
444       P:0000DA P:0000DA 0EA0D1            JEQ     <CLR_CC                           ; There is no new SCI word
445       P:0000DB P:0000DB 44D800            MOVE              X:(R0)+,X0
446       P:0000DC P:0000DC 446300            MOVE              X0,X:(R3)
447       P:0000DD P:0000DD 220E00            MOVE              R0,A
448       P:0000DE P:0000DE 0140C5            CMP     #(SCI_TABLE+32),A                 ; Wrap it around the circular
                            000420
449       P:0000E0 P:0000E0 0EA0E4            JEQ     <INIT_PROCESSED_SCI               ;   buffer boundary
450       P:0000E1 P:0000E1 547000            MOVE              A1,X:(SCI_TABLE+33)
                            000421
451       P:0000E3 P:0000E3 0C00E9            JMP     <SCI_END
452                                 INIT_PROCESSED_SCI
453       P:0000E4 P:0000E4 56F400            MOVE              #SCI_TABLE,A
                            000400
454       P:0000E6 P:0000E6 000000            NOP
455       P:0000E7 P:0000E7 567000            MOVE              A,X:(SCI_TABLE+33)
                            000421
456       P:0000E9 P:0000E9 0A0020  SCI_END   BSET    #ST_RCV,X:<STATUS                 ; Its a utility board (SCI) word
457       P:0000EA P:0000EA 0C00CC            JMP     <SET_CC
458    
459                                 ; Transmit the word in B1 to the host computer over the fiber optic data link
460                                 XMT_WRD
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 9



461       P:0000EB P:0000EB 08F4BB            MOVEP             #$028FE2,X:BCR          ; Slow down RDFO access
                            028FE2
462       P:0000ED P:0000ED 60F400            MOVE              #FO_HDR+1,R0
                            000002
463       P:0000EF P:0000EF 060380            DO      #3,XMT_WRD1
                            0000F3
464       P:0000F1 P:0000F1 0C1D91            ASL     #8,B,B
465       P:0000F2 P:0000F2 000000            NOP
466       P:0000F3 P:0000F3 535800            MOVE              B2,X:(R0)+
467                                 XMT_WRD1
468       P:0000F4 P:0000F4 60F400            MOVE              #FO_HDR,R0
                            000001
469       P:0000F6 P:0000F6 61F400            MOVE              #WRFO,R1
                            FFFFF2
470       P:0000F8 P:0000F8 060480            DO      #4,XMT_WRD2
                            0000FB
471       P:0000FA P:0000FA 46D800            MOVE              X:(R0)+,Y0              ; Should be MOVEP  X:(R0)+,Y:WRFO
472       P:0000FB P:0000FB 4E6100            MOVE                          Y0,Y:(R1)
473                                 XMT_WRD2
474       P:0000FC P:0000FC 08F4BB            MOVEP             #$028FE1,X:BCR          ; Restore RDFO access
                            028FE1
475       P:0000FE P:0000FE 00000C            RTS
476    
477                                 ; Check the command or reply header in X:(R3) for self-consistency
478       P:0000FF P:0000FF 46E300  CHK_HDR   MOVE              X:(R3),Y0
479       P:000100 P:000100 579600            MOVE              X:<MASK1,B              ; Test for S.LE.3 and D.LE.3 and N.LE.7
480       P:000101 P:000101 20005E            AND     Y0,B
481       P:000102 P:000102 0E208D            JNE     <ERROR                            ; Test failed
482       P:000103 P:000103 579700            MOVE              X:<MASK2,B              ; Test for either S.NE.0 or D.NE.0
483       P:000104 P:000104 20005E            AND     Y0,B
484       P:000105 P:000105 0EA08D            JEQ     <ERROR                            ; Test failed
485       P:000106 P:000106 579500            MOVE              X:<SEVEN,B
486       P:000107 P:000107 20005E            AND     Y0,B                              ; Extract NWORDS, must be > 0
487       P:000108 P:000108 0EA08D            JEQ     <ERROR
488       P:000109 P:000109 44E300            MOVE              X:(R3),X0
489       P:00010A P:00010A 440500            MOVE              X0,X:<HEADER            ; Its a correct header
490       P:00010B P:00010B 550600            MOVE              B1,X:<NWORDS            ; Number of words in the command
491       P:00010C P:00010C 0C005E            JMP     <PR_RCV
492    
493                                 ;  *****************  Boot Commands  *******************
494    
495                                 ; Test Data Link - simply return value received after 'TDL'
496       P:00010D P:00010D 47DB00  TDL       MOVE              X:(R3)+,Y1              ; Get the data value
497       P:00010E P:00010E 0C0090            JMP     <FINISH1                          ; Return from executing TDL command
498    
499                                 ; Read DSP or EEPROM memory ('RDM' address): read memory, reply with value
500       P:00010F P:00010F 47DB00  RDMEM     MOVE              X:(R3)+,Y1
501       P:000110 P:000110 20EF00            MOVE              Y1,B
502       P:000111 P:000111 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
503       P:000113 P:000113 21B000            MOVE              B1,R0                   ; Need the address in an address register
504       P:000114 P:000114 20EF00            MOVE              Y1,B
505       P:000115 P:000115 000000            NOP
506       P:000116 P:000116 0ACF14            JCLR    #20,B,RDX                         ; Test address bit for Program memory
                            00011A
507       P:000118 P:000118 07E087            MOVE              P:(R0),Y1               ; Read from Program Memory
508       P:000119 P:000119 0C0090            JMP     <FINISH1                          ; Send out a header with the value
509       P:00011A P:00011A 0ACF15  RDX       JCLR    #21,B,RDY                         ; Test address bit for X: memory
                            00011E
510       P:00011C P:00011C 47E000            MOVE              X:(R0),Y1               ; Write to X data memory
511       P:00011D P:00011D 0C0090            JMP     <FINISH1                          ; Send out a header with the value
512       P:00011E P:00011E 0ACF16  RDY       JCLR    #22,B,RDR                         ; Test address bit for Y: memory
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 10



                            000122
513       P:000120 P:000120 4FE000            MOVE                          Y:(R0),Y1   ; Read from Y data memory
514       P:000121 P:000121 0C0090            JMP     <FINISH1                          ; Send out a header with the value
515       P:000122 P:000122 0ACF17  RDR       JCLR    #23,B,ERROR                       ; Test address bit for read from EEPROM memo
ry
                            00008D
516       P:000124 P:000124 479400            MOVE              X:<THREE,Y1             ; Convert to word address to a byte address
517       P:000125 P:000125 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
518       P:000126 P:000126 2000B8            MPY     Y0,Y1,B                           ; Multiply
519       P:000127 P:000127 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
520       P:000128 P:000128 213000            MOVE              B0,R0                   ; Need to address memory
521       P:000129 P:000129 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
522       P:00012A P:00012A 0D0178            JSR     <RD_WORD                          ; Read word from EEPROM
523       P:00012B P:00012B 21A700            MOVE              B1,Y1                   ; FINISH1 transmits Y1 as its reply
524       P:00012C P:00012C 0C0090            JMP     <FINISH1
525    
526                                 ; Program WRMEM ('WRM' address datum): write to memory, reply 'DON'.
527       P:00012D P:00012D 47DB00  WRMEM     MOVE              X:(R3)+,Y1              ; Get the address to be written to
528       P:00012E P:00012E 20EF00            MOVE              Y1,B
529       P:00012F P:00012F 0140CE            AND     #$0FFFFF,B                        ; Bits 23-20 need to be zeroed
                            0FFFFF
530       P:000131 P:000131 21B000            MOVE              B1,R0                   ; Need the address in an address register
531       P:000132 P:000132 20EF00            MOVE              Y1,B
532       P:000133 P:000133 46DB00            MOVE              X:(R3)+,Y0              ; Get datum into Y0 so MOVE works easily
533       P:000134 P:000134 0ACF14            JCLR    #20,B,WRX                         ; Test address bit for Program memory
                            000138
534       P:000136 P:000136 076086            MOVE              Y0,P:(R0)               ; Write to Program memory
535       P:000137 P:000137 0C008F            JMP     <FINISH
536       P:000138 P:000138 0ACF15  WRX       JCLR    #21,B,WRY                         ; Test address bit for X: memory
                            00013C
537       P:00013A P:00013A 466000            MOVE              Y0,X:(R0)               ; Write to X: memory
538       P:00013B P:00013B 0C008F            JMP     <FINISH
539       P:00013C P:00013C 0ACF16  WRY       JCLR    #22,B,WRR                         ; Test address bit for Y: memory
                            000140
540       P:00013E P:00013E 4E6000            MOVE                          Y0,Y:(R0)   ; Write to Y: memory
541       P:00013F P:00013F 0C008F            JMP     <FINISH
542       P:000140 P:000140 0ACF17  WRR       JCLR    #23,B,ERROR                       ; Test address bit for write to EEPROM
                            00008D
543       P:000142 P:000142 013D02            BCLR    #WRENA,X:PDRC                     ; WR_ENA* = 0 to enable EEPROM writing
544       P:000143 P:000143 460E00            MOVE              Y0,X:<SV_A1             ; Save the datum to be written
545       P:000144 P:000144 479400            MOVE              X:<THREE,Y1             ; Convert word address to a byte address
546       P:000145 P:000145 220600            MOVE              R0,Y0                   ; Get 16-bit address in a data register
547       P:000146 P:000146 2000B8            MPY     Y1,Y0,B                           ; Multiply
548       P:000147 P:000147 20002A            ASR     B                                 ; Eliminate zero fill of fractional multiply
549       P:000148 P:000148 213000            MOVE              B0,R0                   ; Need to address memory
550       P:000149 P:000149 0AD06F            BSET    #15,R0                            ; Set bit so its in EEPROM space
551       P:00014A P:00014A 558E00            MOVE              X:<SV_A1,B1             ; Get the datum to be written
552       P:00014B P:00014B 060380            DO      #3,L1WRR                          ; Loop over three bytes of the word
                            000154
553       P:00014D P:00014D 07588D            MOVE              B1,P:(R0)+              ; Write each EEPROM byte
554       P:00014E P:00014E 0C1C91            ASR     #8,B,B
555       P:00014F P:00014F 469E00            MOVE              X:<C100K,Y0             ; Move right one byte, enter delay = 1 msec
556       P:000150 P:000150 06C600            DO      Y0,L2WRR                          ; Delay by 12 milliseconds for EEPROM write
                            000153
557       P:000152 P:000152 060CA0            REP     #12                               ; Assume 100 MHz DSP56303
558       P:000153 P:000153 000000            NOP
559                                 L2WRR
560       P:000154 P:000154 000000            NOP                                       ; DO loop nesting restriction
561                                 L1WRR
562       P:000155 P:000155 013D22            BSET    #WRENA,X:PDRC                     ; WR_ENA* = 1 to disable EEPROM writing
563    
564       P:000156 P:000156 0C008F            JMP     <FINISH
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 11



565    
566                                 ; Load application code from P: memory into its proper locations
567       P:000157 P:000157 47DB00  LDAPPL    MOVE              X:(R3)+,Y1              ; Application number, not used yet
568       P:000158 P:000158 0D015A            JSR     <LOAD_APPLICATION
569       P:000159 P:000159 0C008F            JMP     <FINISH
570    
571                                 LOAD_APPLICATION
572       P:00015A P:00015A 60F400            MOVE              #$8000,R0               ; Starting EEPROM address
                            008000
573       P:00015C P:00015C 0D0178            JSR     <RD_WORD                          ; Number of words in boot code
574       P:00015D P:00015D 21A600            MOVE              B1,Y0
575       P:00015E P:00015E 479400            MOVE              X:<THREE,Y1
576       P:00015F P:00015F 2000B8            MPY     Y0,Y1,B
577       P:000160 P:000160 20002A            ASR     B
578       P:000161 P:000161 213000            MOVE              B0,R0                   ; EEPROM address of start of P: application
579       P:000162 P:000162 0AD06F            BSET    #15,R0                            ; To access EEPROM
580       P:000163 P:000163 0D0178            JSR     <RD_WORD                          ; Read number of words in application P:
581       P:000164 P:000164 61F400            MOVE              #(X_BOOT_START+1),R1    ; End of boot P: code that needs keeping
                            00022B
582       P:000166 P:000166 06CD00            DO      B1,RD_APPL_P
                            000169
583       P:000168 P:000168 0D0178            JSR     <RD_WORD
584       P:000169 P:000169 07598D            MOVE              B1,P:(R1)+
585                                 RD_APPL_P
586       P:00016A P:00016A 0D0178            JSR     <RD_WORD                          ; Read number of words in application X:
587       P:00016B P:00016B 61F400            MOVE              #END_COMMAND_TABLE,R1
                            000036
588       P:00016D P:00016D 06CD00            DO      B1,RD_APPL_X
                            000170
589       P:00016F P:00016F 0D0178            JSR     <RD_WORD
590       P:000170 P:000170 555900            MOVE              B1,X:(R1)+
591                                 RD_APPL_X
592       P:000171 P:000171 0D0178            JSR     <RD_WORD                          ; Read number of words in application Y:
593       P:000172 P:000172 310100            MOVE              #1,R1                   ; There is no Y: memory in the boot code
594       P:000173 P:000173 06CD00            DO      B1,RD_APPL_Y
                            000176
595       P:000175 P:000175 0D0178            JSR     <RD_WORD
596       P:000176 P:000176 5D5900            MOVE                          B1,Y:(R1)+
597                                 RD_APPL_Y
598       P:000177 P:000177 00000C            RTS
599    
600                                 ; Read one word from EEPROM location R0 into accumulator B1
601       P:000178 P:000178 060380  RD_WORD   DO      #3,L_RDBYTE
                            00017B
602       P:00017A P:00017A 07D88B            MOVE              P:(R0)+,B2
603       P:00017B P:00017B 0C1C91            ASR     #8,B,B
604                                 L_RDBYTE
605       P:00017C P:00017C 00000C            RTS
606    
607                                 ; Come to here on a 'STP' command so 'DON' can be sent
608                                 STOP_IDLE_CLOCKING
609       P:00017D P:00017D 305A00            MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
610       P:00017E P:00017E 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
611       P:00017F P:00017F 0A0002            BCLR    #IDLMODE,X:<STATUS                ; Don't idle after readout
612       P:000180 P:000180 0C008F            JMP     <FINISH
613    
614                                 ; Routines executed after the DSP boots and initializes
615       P:000181 P:000181 305A00  STARTUP   MOVE              #<TST_RCV,R0            ; Execution address when idle => when not
616       P:000182 P:000182 601F00            MOVE              R0,X:<IDL_ADR           ;   processing commands or reading out
617       P:000183 P:000183 44F400            MOVE              #50000,X0               ; Delay by 500 milliseconds
                            00C350
618       P:000185 P:000185 06C400            DO      X0,L_DELAY
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 12



                            000188
619       P:000187 P:000187 06E8A3            REP     #1000
620       P:000188 P:000188 000000            NOP
621                                 L_DELAY
622       P:000189 P:000189 57F400            MOVE              #$020002,B              ; Normal reply after booting is 'SYR'
                            020002
623       P:00018B P:00018B 0D00EB            JSR     <XMT_WRD
624       P:00018C P:00018C 57F400            MOVE              #'SYR',B
                            535952
625       P:00018E P:00018E 0D00EB            JSR     <XMT_WRD
626    
627       P:00018F P:00018F 0C0054            JMP     <START                            ; Start normal command processing
628    
629                                 ; *******************  DSP  INITIALIZATION  CODE  **********************
630                                 ; This code initializes the DSP right after booting, and is overwritten
631                                 ;   by application code
632       P:000190 P:000190 08F4BD  INIT      MOVEP             #PLL_INIT,X:PCTL        ; Initialize PLL to 100 MHz
                            050003
633       P:000192 P:000192 000000            NOP
634    
635                                 ; Set operation mode register OMR to normal expanded
636       P:000193 P:000193 0500BA            MOVEC             #$0000,OMR              ; Operating Mode Register = Normal Expanded
637       P:000194 P:000194 0500BB            MOVEC             #0,SP                   ; Reset the Stack Pointer SP
638    
639                                 ; Program the AA = address attribute pins
640       P:000195 P:000195 08F4B9            MOVEP             #$FFFC21,X:AAR0         ; Y = $FFF000 to $FFFFFF asserts commands
                            FFFC21
641       P:000197 P:000197 08F4B8            MOVEP             #$008909,X:AAR1         ; P = $008000 to $00FFFF accesses the EEPROM
                            008909
642       P:000199 P:000199 08F4B7            MOVEP             #$010C11,X:AAR2         ; X = $010000 to $010FFF reads A/D values
                            010C11
643       P:00019B P:00019B 08F4B6            MOVEP             #$080621,X:AAR3         ; Y = $080000 to $0BFFFF R/W from SRAM
                            080621
644    
645                                 ; Program the DRAM memory access and addressing
646       P:00019D P:00019D 08F4BB            MOVEP             #$028FE1,X:BCR          ; Bus Control Register
                            028FE1
647    
648                                 ; Program the Host port B for parallel I/O
649       P:00019F P:00019F 08F484            MOVEP             #>1,X:HPCR              ; All pins enabled as GPIO
                            000001
650       P:0001A1 P:0001A1 08F489            MOVEP             #$810C,X:HDR
                            00810C
651       P:0001A3 P:0001A3 08F488            MOVEP             #$B10E,X:HDDR           ; Data Direction Register
                            00B10E
652                                                                                     ;  (1 for Output, 0 for Input)
653    
654                                 ; Port B conversion from software bits to schematic labels
655                                 ;       PB0 = PWROK             PB08 = PRSFIFO*
656                                 ;       PB1 = LED1              PB09 = EF*
657                                 ;       PB2 = LVEN              PB10 = EXT-IN0
658                                 ;       PB3 = HVEN              PB11 = EXT-IN1
659                                 ;       PB4 = STATUS0           PB12 = EXT-OUT0
660                                 ;       PB5 = STATUS1           PB13 = EXT-OUT1
661                                 ;       PB6 = STATUS2           PB14 = SSFHF*
662                                 ;       PB7 = STATUS3           PB15 = SELSCI
663    
664                                 ; Program the serial port ESSI0 = Port C for serial communication with
665                                 ;   the utility board
666       P:0001A5 P:0001A5 07F43F            MOVEP             #>0,X:PCRC              ; Software reset of ESSI0
                            000000
667       P:0001A7 P:0001A7 07F435            MOVEP             #$180809,X:CRA0         ; Divide 100 MHz by 20 to get 5.0 MHz
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 13



                            180809
668                                                                                     ; DC[4:0] = 0 for non-network operation
669                                                                                     ; WL0-WL2 = 3 for 24-bit data words
670                                                                                     ; SSC1 = 0 for SC1 not used
671       P:0001A9 P:0001A9 07F436            MOVEP             #$020020,X:CRB0         ; SCKD = 1 for internally generated clock
                            020020
672                                                                                     ; SCD2 = 0 so frame sync SC2 is an output
673                                                                                     ; SHFD = 0 for MSB shifted first
674                                                                                     ; FSL = 0, frame sync length not used
675                                                                                     ; CKP = 0 for rising clock edge transitions
676                                                                                     ; SYN = 0 for asynchronous
677                                                                                     ; TE0 = 1 to enable transmitter #0
678                                                                                     ; MOD = 0 for normal, non-networked mode
679                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
680                                                                                     ; RE = 1 to enable receiver
681       P:0001AB P:0001AB 07F43F            MOVEP             #%111001,X:PCRC         ; Control Register (0 for GPIO, 1 for ESSI)
                            000039
682       P:0001AD P:0001AD 07F43E            MOVEP             #%000110,X:PRRC         ; Data Direction Register (0 for In, 1 for O
ut)
                            000006
683       P:0001AF P:0001AF 07F43D            MOVEP             #%000100,X:PDRC         ; Data Register - WR_ENA* = 1
                            000004
684    
685                                 ; Port C version = Analog boards
686                                 ;       MOVEP   #$000809,X:CRA0 ; Divide 100 MHz by 20 to get 5.0 MHz
687                                 ;       MOVEP   #$000030,X:CRB0 ; SCKD = 1 for internally generated clock
688                                 ;       MOVEP   #%100000,X:PCRC ; Control Register (0 for GPIO, 1 for ESSI)
689                                 ;       MOVEP   #%000100,X:PRRC ; Data Direction Register (0 for In, 1 for Out)
690                                 ;       MOVEP   #%000000,X:PDRC ; Data Register: 'not used' = 0 outputs
691    
692       P:0001B1 P:0001B1 07F43C            MOVEP             #0,X:TX00               ; Initialize the transmitter to zero
                            000000
693       P:0001B3 P:0001B3 000000            NOP
694       P:0001B4 P:0001B4 000000            NOP
695       P:0001B5 P:0001B5 013630            BSET    #TE,X:CRB0                        ; Enable the SSI transmitter
696    
697                                 ; Conversion from software bits to schematic labels for Port C
698                                 ;       PC0 = SC00 = UTL-T-SCK
699                                 ;       PC1 = SC01 = 2_XMT = SYNC on prototype
700                                 ;       PC2 = SC02 = WR_ENA*
701                                 ;       PC3 = SCK0 = TIM-U-SCK
702                                 ;       PC4 = SRD0 = UTL-T-STD
703                                 ;       PC5 = STD0 = TIM-U-STD
704    
705                                 ; Program the serial port ESSI1 = Port D for serial transmission to
706                                 ;   the analog boards and two parallel I/O input pins
707       P:0001B6 P:0001B6 07F42F            MOVEP             #>0,X:PCRD              ; Software reset of ESSI0
                            000000
708       P:0001B8 P:0001B8 07F425            MOVEP             #$000809,X:CRA1         ; Divide 100 MHz by 20 to get 5.0 MHz
                            000809
709                                                                                     ; DC[4:0] = 0
710                                                                                     ; WL[2:0] = ALC = 0 for 8-bit data words
711                                                                                     ; SSC1 = 0 for SC1 not used
712       P:0001BA P:0001BA 07F426            MOVEP             #$000030,X:CRB1         ; SCKD = 1 for internally generated clock
                            000030
713                                                                                     ; SCD2 = 1 so frame sync SC2 is an output
714                                                                                     ; SHFD = 0 for MSB shifted first
715                                                                                     ; CKP = 0 for rising clock edge transitions
716                                                                                     ; TE0 = 0 to NOT enable transmitter #0 yet
717                                                                                     ; MOD = 0 so its not networked mode
718       P:0001BC P:0001BC 07F42F            MOVEP             #%100000,X:PCRD         ; Control Register (0 for GPIO, 1 for ESSI)
                            000020
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 14



719                                                                                     ; PD3 = SCK1, PD5 = STD1 for ESSI
720       P:0001BE P:0001BE 07F42E            MOVEP             #%000100,X:PRRD         ; Data Direction Register (0 for In, 1 for O
ut)
                            000004
721       P:0001C0 P:0001C0 07F42D            MOVEP             #%000100,X:PDRD         ; Data Register: 'not used' = 0 outputs
                            000004
722       P:0001C2 P:0001C2 07F42C            MOVEP             #0,X:TX10               ; Initialize the transmitter to zero
                            000000
723       P:0001C4 P:0001C4 000000            NOP
724       P:0001C5 P:0001C5 000000            NOP
725       P:0001C6 P:0001C6 012630            BSET    #TE,X:CRB1                        ; Enable the SSI transmitter
726    
727                                 ; Conversion from software bits to schematic labels for Port D
728                                 ; PD0 = SC10 = 2_XMT_? input
729                                 ; PD1 = SC11 = SSFEF* input
730                                 ; PD2 = SC12 = PWR_EN
731                                 ; PD3 = SCK1 = TIM-A-SCK
732                                 ; PD4 = SRD1 = PWRRST
733                                 ; PD5 = STD1 = TIM-A-STD
734    
735                                 ; Program the SCI port to communicate with the utility board
736       P:0001C7 P:0001C7 07F41C            MOVEP             #$0B04,X:SCR            ; SCI programming: 11-bit asynchronous
                            000B04
737                                                                                     ;   protocol (1 start, 8 data, 1 even parity
,
738                                                                                     ;   1 stop); LSB before MSB; enable receiver
739                                                                                     ;   and its interrupts; transmitter interrup
ts
740                                                                                     ;   disabled.
741       P:0001C9 P:0001C9 07F41B            MOVEP             #$0003,X:SCCR           ; SCI clock: utility board data rate =
                            000003
742                                                                                     ;   (390,625 kbits/sec); internal clock.
743       P:0001CB P:0001CB 07F41F            MOVEP             #%011,X:PCRE            ; Port Control Register = RXD, TXD enabled
                            000003
744       P:0001CD P:0001CD 07F41E            MOVEP             #%000,X:PRRE            ; Port Direction Register (0 = Input)
                            000000
745    
746                                 ;       PE0 = RXD
747                                 ;       PE1 = TXD
748                                 ;       PE2 = SCLK
749    
750                                 ; Program one of the three timers as an exposure timer
751       P:0001CF P:0001CF 07F403            MOVEP             #$C34F,X:TPLR           ; Prescaler to generate millisecond timer,
                            00C34F
752                                                                                     ;  counting from the system clock / 2 = 50 M
Hz
753       P:0001D1 P:0001D1 07F40F            MOVEP             #$208200,X:TCSR0        ; Clear timer complete bit and enable presca
ler
                            208200
754       P:0001D3 P:0001D3 07F40E            MOVEP             #0,X:TLR0               ; Timer load register
                            000000
755    
756                                 ; Enable interrupts for the SCI port only
757       P:0001D5 P:0001D5 08F4BF            MOVEP             #$000000,X:IPRC         ; No interrupts allowed
                            000000
758       P:0001D7 P:0001D7 08F4BE            MOVEP             #>$80,X:IPRP            ; Enable SCI interrupt only, IPR = 1
                            000080
759       P:0001D9 P:0001D9 00FCB8            ANDI    #$FC,MR                           ; Unmask all interrupt levels
760    
761                                 ; Initialize the fiber optic serial receiver circuitry
762       P:0001DA P:0001DA 061480            DO      #20,L_FO_INIT
                            0001DF
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 15



763       P:0001DC P:0001DC 5FF000            MOVE                          Y:RDFO,B
                            FFFFF1
764       P:0001DE P:0001DE 0605A0            REP     #5
765       P:0001DF P:0001DF 000000            NOP
766                                 L_FO_INIT
767    
768                                 ; Pulse PRSFIFO* low to revive the CMDRST* instruction and reset the FIFO
769       P:0001E0 P:0001E0 44F400            MOVE              #1000000,X0             ; Delay by 10 milliseconds
                            0F4240
770       P:0001E2 P:0001E2 06C400            DO      X0,*+3
                            0001E4
771       P:0001E4 P:0001E4 000000            NOP
772       P:0001E5 P:0001E5 0A8908            BCLR    #8,X:HDR
773       P:0001E6 P:0001E6 0614A0            REP     #20
774       P:0001E7 P:0001E7 000000            NOP
775       P:0001E8 P:0001E8 0A8928            BSET    #8,X:HDR
776    
777                                 ; Reset the utility board
778       P:0001E9 P:0001E9 0A0F05            BCLR    #5,X:<LATCH
779       P:0001EA P:0001EA 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
780       P:0001EC P:0001EC 06C8A0            REP     #200                              ; Delay by RESET* low time
781       P:0001ED P:0001ED 000000            NOP
782       P:0001EE P:0001EE 0A0F25            BSET    #5,X:<LATCH
783       P:0001EF P:0001EF 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Clear reset utility board bit
                            00000F
784       P:0001F1 P:0001F1 56F400            MOVE              #200000,A               ; Delay 2 msec for utility boot
                            030D40
785       P:0001F3 P:0001F3 06CE00            DO      A,*+3
                            0001F5
786       P:0001F5 P:0001F5 000000            NOP
787    
788                                 ; Put all the analog switch inputs to low so they draw minimum current
789       P:0001F6 P:0001F6 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
790       P:0001F7 P:0001F7 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
791       P:0001F9 P:0001F9 20001B            CLR     B
792       P:0001FA P:0001FA 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
793       P:0001FB P:0001FB 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
794       P:0001FD P:0001FD 060F80            DO      #15,L_ANALOG                      ; Fifteen video processor boards maximum
                            000205
795       P:0001FF P:0001FF 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
796       P:000200 P:000200 200040            ADD     X0,A
797       P:000201 P:000201 5F7000            MOVE                          B,Y:WRSS    ; This is for the fast analog switches
                            FFFFF3
798       P:000203 P:000203 0620A3            REP     #800                              ; Delay for the serial data transmission
799       P:000204 P:000204 000000            NOP
800       P:000205 P:000205 200068            ADD     X1,B                              ; Increment the video and clock driver numbe
rs
801                                 L_ANALOG
802       P:000206 P:000206 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
803       P:000207 P:000207 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
804       P:000208 P:000208 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
805       P:00020A P:00020A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
806       P:00020B P:00020B 0C0223            JMP     <SKIP
807    
808                                 ; Transmit contents of accumulator A1 over the synchronous serial transmitter
809                                 XMIT_A_WORD
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 16



810       P:00020C P:00020C 07F42C            MOVEP             #0,X:TX10               ; This helps, don't know why
                            000000
811       P:00020E P:00020E 547000            MOVE              A1,X:SV_A1
                            00000E
812       P:000210 P:000210 000000            NOP
813       P:000211 P:000211 01A786            JCLR    #TDE,X:SSISR1,*                   ; Start bit
                            000211
814       P:000213 P:000213 07F42C            MOVEP             #$010000,X:TX10
                            010000
815       P:000215 P:000215 060380            DO      #3,L_X
                            00021B
816       P:000217 P:000217 01A786            JCLR    #TDE,X:SSISR1,*                   ; Three data bytes
                            000217
817       P:000219 P:000219 04CCCC            MOVEP             A1,X:TX10
818       P:00021A P:00021A 0C1E90            LSL     #8,A
819       P:00021B P:00021B 000000            NOP
820                                 L_X
821       P:00021C P:00021C 01A786            JCLR    #TDE,X:SSISR1,*                   ; Zeroes to bring transmitter low
                            00021C
822       P:00021E P:00021E 07F42C            MOVEP             #0,X:TX10
                            000000
823       P:000220 P:000220 54F000            MOVE              X:SV_A1,A1
                            00000E
824       P:000222 P:000222 00000C            RTS
825    
826                                 SKIP
827    
828                                 ; Set up the circular SCI buffer, 32 words in size
829       P:000223 P:000223 64F400            MOVE              #SCI_TABLE,R4
                            000400
830       P:000225 P:000225 051FA4            MOVE              #31,M4
831       P:000226 P:000226 647000            MOVE              R4,X:(SCI_TABLE+33)
                            000421
832    
833                                           IF      @SCP("HOST","ROM")
841                                           ENDIF
842    
843       P:000228 P:000228 44F400            MOVE              #>$AC,X0
                            0000AC
844       P:00022A P:00022A 440100            MOVE              X0,X:<FO_HDR
845    
846       P:00022B P:00022B 0C0181            JMP     <STARTUP
847    
848                                 ;  ****************  X: Memory tables  ********************
849    
850                                 ; Define the address in P: space where the table of constants begins
851    
852                                  X_BOOT_START
853       00022A                              EQU     @LCV(L)-2
854    
855                                           IF      @SCP("HOST","ROM")
857                                           ENDIF
858                                           IF      @SCP("HOST","HOST")
859       X:000000 X:000000                   ORG     X:0,X:0
860                                           ENDIF
861    
862                                 ; Special storage area - initialization constants and scratch space
863       X:000000 X:000000         STATUS    DC      $1064                             ; Controller status bits
864    
865       000001                    FO_HDR    EQU     STATUS+1                          ; Fiber optic write bytes
866       000005                    HEADER    EQU     FO_HDR+4                          ; Command header
867       000006                    NWORDS    EQU     HEADER+1                          ; Number of words in the command
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 17



868       000007                    COM_BUF   EQU     NWORDS+1                          ; Command buffer
869       00000E                    SV_A1     EQU     COM_BUF+7                         ; Save accumulator A1
870    
871                                           IF      @SCP("HOST","ROM")
876                                           ENDIF
877    
878                                           IF      @SCP("HOST","HOST")
879       X:00000F X:00000F                   ORG     X:$F,X:$F
880                                           ENDIF
881    
882                                 ; Parameter table in P: space to be copied into X: space during
883                                 ;   initialization, and is copied from ROM by the DSP boot
884       X:00000F X:00000F         LATCH     DC      $7A                               ; Starting value in latch chip U25
885                                  EXPOSURE_TIME
886       X:000010 X:000010                   DC      0                                 ; Exposure time in milliseconds
887                                  ELAPSED_TIME
888       X:000011 X:000011                   DC      0                                 ; Time elapsed so far in the exposure
889       X:000012 X:000012         ONE       DC      1                                 ; One
890       X:000013 X:000013         TWO       DC      2                                 ; Two
891       X:000014 X:000014         THREE     DC      3                                 ; Three
892       X:000015 X:000015         SEVEN     DC      7                                 ; Seven
893       X:000016 X:000016         MASK1     DC      $FCFCF8                           ; Mask for checking header
894       X:000017 X:000017         MASK2     DC      $030300                           ; Mask for checking header
895       X:000018 X:000018         DONE      DC      'DON'                             ; Standard reply
896       X:000019 X:000019         SBRD      DC      $020000                           ; Source Identification number
897       X:00001A X:00001A         TIM_DRB   DC      $000200                           ; Destination = timing board number
898       X:00001B X:00001B         DMASK     DC      $00FF00                           ; Mask to get destination board number
899       X:00001C X:00001C         SMASK     DC      $FF0000                           ; Mask to get source board number
900       X:00001D X:00001D         ERR       DC      'ERR'                             ; An error occurred
901       X:00001E X:00001E         C100K     DC      100000                            ; Delay for WRROM = 1 millisec
902       X:00001F X:00001F         IDL_ADR   DC      TST_RCV                           ; Address of idling routine
903       X:000020 X:000020         EXP_ADR   DC      0                                 ; Jump to this address during exposures
904    
905    
906                                 ; Places for saving register values
907       X:000021 X:000021         SAVE_SR   DC      0                                 ; Status Register
908       X:000022 X:000022         SAVE_X1   DC      0
909       X:000023 X:000023         SAVE_A1   DC      0
910       X:000024 X:000024         SAVE_R0   DC      0
911       X:000025 X:000025         RCV_ERR   DC      0
912       X:000026 X:000026         SCI_A1    DC      0                                 ; Contents of accumulator A1 in RCV ISR
913       X:000027 X:000027         SCI_R0    DC      SRXL
914    
915                                 ; Command table
916       000028                    COM_TBL_R EQU     @LCV(R)
917       X:000028 X:000028         COM_TBL   DC      'TDL',TDL                         ; Test Data Link
918       X:00002A X:00002A                   DC      'RDM',RDMEM                       ; Read from DSP or EEPROM memory
919       X:00002C X:00002C                   DC      'WRM',WRMEM                       ; Write to DSP memory
920       X:00002E X:00002E                   DC      'LDA',LDAPPL                      ; Load application from EEPROM to DSP
921       X:000030 X:000030                   DC      'STP',STOP_IDLE_CLOCKING
922       X:000032 X:000032                   DC      'DON',START                       ; Nothing special
923       X:000034 X:000034                   DC      'ERR',START                       ; Nothing special
924    
925                                  END_COMMAND_TABLE
926       000036                              EQU     @LCV(R)
927    
928                                 ; The table at SCI_TABLE is for words received from the utility board, written by
929                                 ;   the interrupt service routine SCI_RCV. Note that it is 32 words long,
930                                 ;   hard coded, and the 33rd location contains the pointer to words that have
931                                 ;   been processed by moving them from the SCI_TABLE to the COM_BUF.
932    
933                                           IF      @SCP("HOST","ROM")
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timboot.asm  Page 18



935                                           ENDIF
936    
937       000036                    END_ADR   EQU     @LCV(L)                           ; End address of P: code written to ROM
938    
939       P:00022C P:00022C                   ORG     P:,P:
940    
941       001DB4                    CC        EQU     CCDVIDREV5+TIMREV5+TEMP_POLY+UTILREV3+SPLIT_SERIAL+SUBARRAY+BINNING+SHUTTER_CC
942    
943                                 ; Put number of words of application in P: for loading application from EEPROM
944       P:00022C P:00022C                   DC      TIMBOOT_X_MEMORY-@LCV(L)-1
945    
946                                 ; Define CLOCK as a macro to produce in-line code to reduce execution time
947                                 CLOCK     MACRO
948  m                                        JCLR    #SSFHF,X:HDR,*                    ; Don't overfill the WRSS FIFO
949  m                                        REP     Y:(R0)+                           ; Repeat # of times at address Y:(R0)+
950  m                                        MOVEP   Y:(R0)+,Y:WRSS                    ; Write the waveform to the FIFO
951  m                                        ENDM
952    
953                                 ; Set software to IDLE mode
954                                 START_IDLE_CLOCKING
955       P:00022D P:00022D 60F400            MOVE              #IDLE,R0
                            000233
956       P:00022F P:00022F 000000            NOP
957       P:000230 P:000230 601F00            MOVE              R0,X:<IDL_ADR
958       P:000231 P:000231 0A0022            BSET    #IDLMODE,X:<STATUS                ; Idle after readout
959       P:000232 P:000232 0C008F            JMP     <FINISH                           ; Need to send header and 'DON'
960    
961                                 ; Keep the CCD idling when not reading out
962                                 IDLE
963       P:000233 P:000233 5E9400            MOVE                          Y:<NSRI,A   ; NSERIALS_READ = NSR
964       P:000234 P:000234 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            000237
965       P:000236 P:000236 200022            ASR     A                                 ; Split serials requires / 2
966       P:000237 P:000237 000000            NOP
967       P:000238 P:000238 06CE00            DO      A,IDL1                            ; Loop over number of pixels per line
                            000245
968       P:00023A P:00023A 68F000            MOVE                          Y:SERIAL_IDLE,R0 ; Serial transfer on pixel
                            000012
969                                           CLOCK                                     ; Go to it
973       P:000240 P:000240 330700            MOVE              #COM_BUF,R3
974       P:000241 P:000241 0D00A5            JSR     <GET_RCV                          ; Check for FO or SSI commands
975       P:000242 P:000242 0E0245            JCC     <NO_COM                           ; Continue IDLE if no commands received
976       P:000243 P:000243 00008C            ENDDO
977       P:000244 P:000244 0C005D            JMP     <PRC_RCV                          ; Go process header and command
978       P:000245 P:000245 000000  NO_COM    NOP
979                                 IDL1
980       P:000246 P:000246 061340            DO      Y:<N_PARALLEL_CLEARS,PAR
                            00024C
981       P:000248 P:000248 689100            MOVE                          Y:<PARALLEL_CLEAR,R0 ; Address of parallel clocking wave
form
982                                           CLOCK                                     ; Go clock out the CCD charge
986                                 PAR
987       P:00024D P:00024D 0C0233            JMP     <IDLE
988    
989    
990                                 ;  *****************  Exposure and readout routines  *****************
991    
992                                 ; Overall loop - transfer and read NPR lines
993                                 RDCCD
994    
995                                 ; Calculate some readout parameters
996       P:00024E P:00024E 5E9B00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 19



997       P:00024F P:00024F 000000            NOP
998       P:000250 P:000250 200003            TST     A
999       P:000251 P:000251 0E225C            JNE     <SUB_IMG
1000      P:000252 P:000252 5C1800            MOVE                          A1,Y:<NP_SKIP ; Zero these all out
1001      P:000253 P:000253 5C1900            MOVE                          A1,Y:<NS_SKP1
1002      P:000254 P:000254 5C1A00            MOVE                          A1,Y:<NS_SKP2
1003      P:000255 P:000255 5E8100            MOVE                          Y:<NSR,A    ; NSERIALS_READ = NSR
1004      P:000256 P:000256 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            000259
1005      P:000258 P:000258 200022            ASR     A                                 ; Split serials requires / 2
1006      P:000259 P:000259 000000            NOP
1007      P:00025A P:00025A 5E0A00            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1008      P:00025B P:00025B 0C0272            JMP     <WT_CLK
1009   
1010                                ; Loop over the required number of subimage boxes
1011      P:00025C P:00025C 67F400  SUB_IMG   MOVE              #READ_TABLE,R7          ; Parameter table for subimage readout
                            00001F
1012      P:00025E P:00025E 061B40            DO      Y:<NBOXES,L_NBOXES                ; Loop over number of boxes
                            0002D2
1013      P:000260 P:000260 4CDF00            MOVE                          Y:(R7)+,X0
1014      P:000261 P:000261 4C1800            MOVE                          X0,Y:<NP_SKIP
1015      P:000262 P:000262 4CDF00            MOVE                          Y:(R7)+,X0
1016      P:000263 P:000263 4D8500            MOVE                          Y:<NSBIN,X1 ; Multiply by serial binning number
1017      P:000264 P:000264 2000A0            MPY     X0,X1,A
1018      P:000265 P:000265 200022            ASR     A
1019      P:000266 P:000266 581900            MOVE                          A0,Y:<NS_SKP1
1020      P:000267 P:000267 4CDF00            MOVE                          Y:(R7)+,X0
1021      P:000268 P:000268 4D8500            MOVE                          Y:<NSBIN,X1 ; Multiply by serial binning number
1022      P:000269 P:000269 2000A0            MPY     X0,X1,A
1023      P:00026A P:00026A 200022            ASR     A
1024      P:00026B P:00026B 581A00            MOVE                          A0,Y:<NS_SKP2
1025      P:00026C P:00026C 5E9D00            MOVE                          Y:<NS_READ,A
1026      P:00026D P:00026D 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3             ; Split serials require / 2
                            000270
1027      P:00026F P:00026F 200022            ASR     A
1028      P:000270 P:000270 000000            NOP
1029      P:000271 P:000271 5E0A00            MOVE                          A,Y:<NSERIALS_READ ; Number of columns in each subimage
1030   
1031                                ; Start the loop for parallel shifting desired number of lines
1032                                ;WT_CLK JSR     <GENERATE_SERIAL_WAVEFORM
1033      P:000272 P:000272 000000  WT_CLK    NOP                                       ; not using the binning waveform generation 
at the moment.
1034      P:000273 P:000273 0D0413            JSR     <WAIT_TO_FINISH_CLOCKING
1035   
1036                                ; Skip over the required number of rows for subimage readout
1037      P:000274 P:000274 5E9800            MOVE                          Y:<NP_SKIP,A ; Number of rows to skip
1038      P:000275 P:000275 200003            TST     A
1039      P:000276 P:000276 0EA281            JEQ     <CLR_SR
1040      P:000277 P:000277 061840            DO      Y:<NP_SKIP,L_PSKP
                            000280
1041      P:000279 P:000279 060640            DO      Y:<NPBIN,L_PSKIP
                            00027F
1042      P:00027B P:00027B 301000            MOVE              #<PARALLEL,R0           ; Couldn't this be above the start of the do
 loop?
1043                                          CLOCK
1047      P:000280 P:000280 000000  L_PSKIP   NOP
1048                                L_PSKP
1049   
1050                                ; Clear out the accumulated charge from the serial shift register
1051      P:000281 P:000281 060340  CLR_SR    DO      Y:<NSCLR,L_CLRSR                  ; Loop over number of pixels to skip
                            000287
1052      P:000283 P:000283 688F00            MOVE                          Y:<SERIAL_SKIP,R0
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 20



1053                                          CLOCK                                     ; Go clock out the CCD charge
1057                                L_CLRSR                                             ; Do loop restriction
1058   
1059                                ; Parallel shift the image into the serial shift register
1060      P:000288 P:000288 5E8200            MOVE                          Y:<NPR,A    ; Number of rows set by host computer
1061      P:000289 P:000289 5F9B00            MOVE                          Y:<NBOXES,B ; NBOXES = 0 => full image readout
1062      P:00028A P:00028A 20000B            TST     B
1063      P:00028B P:00028B 0EA28D            JEQ     *+2
1064      P:00028C P:00028C 5E9E00            MOVE                          Y:<NP_READ,A ; If NBOXES .NE. 0 use subimage table
1065      P:00028D P:00028D 000000            NOP
1066   
1067                                ; This is the main loop over each line to be read out
1068      P:00028E P:00028E 06CC00            DO      A1,LPR                            ; Number of rows to read out
                            0002D1
1069   
1070                                ; Exercise the parallel clocks, including binning if needed
1071      P:000290 P:000290 060640            DO      Y:<NPBIN,L_PBIN
                            000296
1072      P:000292 P:000292 689000            MOVE                          Y:<PARALLEL,R0
1073                                          CLOCK
1077                                L_PBIN
1078   
1079                                ; Check for a command once per line. Only the ABORT command should be issued.
1080      P:000297 P:000297 330700            MOVE              #COM_BUF,R3
1081      P:000298 P:000298 0D00A5            JSR     <GET_RCV                          ; Was a command received?
1082      P:000299 P:000299 0E02A3            JCC     <CONTINUE_READ                    ; If no, continue reading out
1083      P:00029A P:00029A 0C005D            JMP     <PRC_RCV                          ; If yes, go process it
1084   
1085                                ; Abort the readout currently underway
1086      P:00029B P:00029B 0A0084  ABR_RDC   JCLR    #ST_RDC,X:<STATUS,ABORT_EXPOSURE
                            0003C0
1087      P:00029D P:00029D 00008C            ENDDO                                     ; Properly terminate readout loop
1088      P:00029E P:00029E 5E9B00            MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1089      P:00029F P:00029F 200003            TST     A
1090      P:0002A0 P:0002A0 0EA2A2            JEQ     *+2
1091      P:0002A1 P:0002A1 00008C            ENDDO                                     ; Properly terminate readout loop
1092      P:0002A2 P:0002A2 0C03C0            JMP     <ABORT_EXPOSURE
1093   
1094                                ; Skip over NS_SKP1 columns for subimage readout
1095                                CONTINUE_READ
1096      P:0002A3 P:0002A3 5E9900            MOVE                          Y:<NS_SKP1,A ; Number of columns to skip
1097      P:0002A4 P:0002A4 200003            TST     A
1098      P:0002A5 P:0002A5 0EF2AD            JLE     <L_READ
1099      P:0002A6 P:0002A6 061940            DO      Y:<NS_SKP1,L_SKP1                 ; Number of waveform entries total
                            0002AC
1100      P:0002A8 P:0002A8 688F00            MOVE                          Y:<SERIAL_SKIP,R0 ; Waveform table starting address
1101                                          CLOCK                                     ; Go clock out the CCD charge
1105                                L_SKP1
1106   
1107                                ; Finally read some real pixels
1108      P:0002AD P:0002AD 060A40  L_READ    DO      Y:<NSERIALS_READ,L_RD
                            0002B3
1109      P:0002AF P:0002AF 688E00            MOVE                          Y:<SERIAL_READ,R0
1110                                          CLOCK                                     ; Go clock out the CCD charge
1114                                L_RD
1115   
1116                                ; Skip over NS_SKP2 columns if needed for subimage readout
1117      P:0002B4 P:0002B4 5E9A00            MOVE                          Y:<NS_SKP2,A ; Number of columns to skip
1118      P:0002B5 P:0002B5 200003            TST     A
1119      P:0002B6 P:0002B6 0EF2BE            JLE     <L_BIAS
1120      P:0002B7 P:0002B7 061A40            DO      Y:<NS_SKP2,L_SKP2
                            0002BD
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 21



1121      P:0002B9 P:0002B9 688F00            MOVE                          Y:<SERIAL_SKIP,R0 ; Waveform table starting address
1122                                          CLOCK                                     ; Go clock out the CCD charge
1126                                L_SKP2
1127   
1128                                ; And read the bias pixels if in subimage readout mode
1129      P:0002BE P:0002BE 5E9B00  L_BIAS    MOVE                          Y:<NBOXES,A ; NBOXES = 0 => full image readout
1130      P:0002BF P:0002BF 200003            TST     A
1131      P:0002C0 P:0002C0 0EF2D1            JLE     <END_ROW
1132      P:0002C1 P:0002C1 5E9C00            MOVE                          Y:<NR_BIAS,A ; NR_BIAS = 0 => no bias pixels
1133      P:0002C2 P:0002C2 200003            TST     A
1134      P:0002C3 P:0002C3 0EF2D1            JLE     <END_ROW
1135      P:0002C4 P:0002C4 0A0085            JCLR    #SPLIT_S,X:STATUS,*+3
                            0002C7
1136      P:0002C6 P:0002C6 200022            ASR     A                                 ; Split serials require / 2
1137      P:0002C7 P:0002C7 000000            NOP
1138      P:0002C8 P:0002C8 06CC00            DO      A1,L_BRD                          ; Number of pixels to read out
                            0002CF
1139      P:0002CA P:0002CA 60F400            MOVE              #PXL_TBL,R0
                            0001DC
1140                                          CLOCK                                     ; Go clock out the CCD charg
1144      P:0002D0 P:0002D0 000000  L_BRD     NOP
1145      P:0002D1 P:0002D1 000000  END_ROW   NOP
1146      P:0002D2 P:0002D2 000000  LPR       NOP                                       ; End of parallel loop
1147      P:0002D3 P:0002D3 000000  L_NBOXES  NOP                                       ; End of subimage boxes loop
1148   
1149                                ; Restore the controller to non-image data transfer and idling if necessary
1150      P:0002D4 P:0002D4 0A0082  RDC_END   JCLR    #IDLMODE,X:<STATUS,NO_IDL         ; Don't idle after readout
                            0002DA
1151      P:0002D6 P:0002D6 60F400            MOVE              #IDLE,R0
                            000233
1152      P:0002D8 P:0002D8 601F00            MOVE              R0,X:<IDL_ADR
1153      P:0002D9 P:0002D9 0C02DC            JMP     <RDC_E
1154      P:0002DA P:0002DA 305A00  NO_IDL    MOVE              #TST_RCV,R0
1155      P:0002DB P:0002DB 601F00            MOVE              R0,X:<IDL_ADR
1156      P:0002DC P:0002DC 0D0413  RDC_E     JSR     <WAIT_TO_FINISH_CLOCKING
1157      P:0002DD P:0002DD 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Set status to not reading out
1158      P:0002DE P:0002DE 0C0054            JMP     <START
1159   
1160                                ; ******  Include many routines not directly needed for readout  *******
1161                                          INCLUDE "timCCDmisc.asm"
1162                                ; Miscellaneous CCD control routines, common to all detector types
1163   
1164                                POWER_OFF
1165      P:0002DF P:0002DF 0D0327            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1166      P:0002E0 P:0002E0 0A8922            BSET    #LVEN,X:HDR
1167      P:0002E1 P:0002E1 0A8923            BSET    #HVEN,X:HDR
1168      P:0002E2 P:0002E2 0A000E            BCLR    #POWERST,X:<STATUS                ; Set the power state in the X: status word
1169      P:0002E3 P:0002E3 0C008F            JMP     <FINISH
1170   
1171                                ; Execute the power-on cycle, as a command
1172                                POWER_ON
1173      P:0002E4 P:0002E4 0D0327            JSR     <CLEAR_SWITCHES                   ; Clear all analog switches
1174      P:0002E5 P:0002E5 0D02F9            JSR     <PON                              ; Turn on the power control board
1175      P:0002E6 P:0002E6 0A8980            JCLR    #PWROK,X:HDR,PWR_ERR              ; Test if the power turned on properly
                            0002F6
1176      P:0002E8 P:0002E8 0D030C            JSR     <SET_BIASES                       ; Turn on the DC bias supplies
1177      P:0002E9 P:0002E9 0D053E            JSR     <SEL_OS                           ; Set up readout parameters
1178      P:0002EA P:0002EA 60F400            MOVE              #IDLE,R0                ; Put controller in IDLE state
                            000233
1179                                ;       MOVE    #TST_RCV,R0             ; Put controller in non-IDLE state
1180      P:0002EC P:0002EC 601F00            MOVE              R0,X:<IDL_ADR
1181      P:0002ED P:0002ED 0A002E            BSET    #POWERST,X:<STATUS                ; Set the power state bit in the X: status w
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 22



ord
1182   
1183                                                                                    ; get the gain setting and put it into the a
ppropriate place in Y memory
1184      P:0002EE P:0002EE 5EF000            MOVE                          Y:GAIN_SETTING,A
                            0001D3
1185      P:0002F0 P:0002F0 240D00            MOVE              #$0D0000,X0
1186      P:0002F1 P:0002F1 200044            SUB     X0,A
1187      P:0002F2 P:0002F2 000000            NOP
1188      P:0002F3 P:0002F3 5E0000            MOVE                          A,Y:<GAIN
1189   
1190                                ; !!!   MOVE    #$1064,X0
1191                                ; !!!   MOVE    X0,X:<STATUS
1192                                ; !!!   JSR     <SEL_OS
1193      P:0002F4 P:0002F4 0A002E            BSET    #POWERST,X:<STATUS                ; Set the power state bit in the X: status w
ord
1194      P:0002F5 P:0002F5 0C008F            JMP     <FINISH
1195   
1196                                ; The power failed to turn on because of an error on the power control board
1197      P:0002F6 P:0002F6 0A8922  PWR_ERR   BSET    #LVEN,X:HDR                       ; Turn off the low voltage enable line
1198      P:0002F7 P:0002F7 0A8923            BSET    #HVEN,X:HDR                       ; Turn off the high voltage enable line
1199      P:0002F8 P:0002F8 0C008D            JMP     <ERROR
1200   
1201                                ; As a subroutine, turn on the low voltages (+/- 6.5V, +/- 16.5V) and delay
1202      P:0002F9 P:0002F9 0A8902  PON       BCLR    #LVEN,X:HDR                       ; Set these signals to DSP outputs
1203      P:0002FA P:0002FA 44F400            MOVE              #2000000,X0
                            1E8480
1204      P:0002FC P:0002FC 06C400            DO      X0,*+3                            ; Wait 20 millisec for settling
                            0002FE
1205      P:0002FE P:0002FE 000000            NOP
1206   
1207                                ; Turn on the high +36 volt power line and then delay
1208      P:0002FF P:0002FF 0A8903            BCLR    #HVEN,X:HDR                       ; HVEN = Low => Turn on +36V
1209      P:000300 P:000300 44F400            MOVE              #10000000,X0
                            989680
1210      P:000302 P:000302 06C400            DO      X0,*+3                            ; Wait 100 millisec for settling
                            000304
1211      P:000304 P:000304 000000            NOP
1212      P:000305 P:000305 00000C            RTS
1213   
1214   
1215                                RAW_COMMAND
1216      P:000306 P:000306 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock
1217   
1218      P:000307 P:000307 56DB00            MOVE              X:(R3)+,A               ; Get the command which should just be a wor
d
1219      P:000308 P:000308 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
1220      P:000309 P:000309 0D0416            JSR     <PAL_DLY                          ; Wait for the number to be sent
1221      P:00030A P:00030A 012F03            BCLR    #3,X:PCRD                         ; Turn off the serial clock
1222      P:00030B P:00030B 0C008F            JMP     <FINISH
1223   
1224                                ; Set all the DC bias voltages and video processor offset values, reading
1225                                ;   them from the 'DACS' table
1226                                SET_BIASES
1227      P:00030C P:00030C 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock
1228      P:00030D P:00030D 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
1229      P:00030E P:00030E 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
1230      P:00030F P:00030F 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
1231      P:000310 P:000310 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
1232      P:000312 P:000312 0D0416            JSR     <PAL_DLY                          ; Delay for all this to happen
1233   
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 23



1234                                ; Read DAC values from a table, and write them to the DACs
1235      P:000313 P:000313 60F400            MOVE              #DACS,R0                ; Get starting address of DAC values
                            000193
1236      P:000315 P:000315 000000            NOP
1237      P:000316 P:000316 000000            NOP
1238      P:000317 P:000317 065840            DO      Y:(R0)+,L_DAC                     ; Repeat Y:(R0)+ times
                            00031B
1239      P:000319 P:000319 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
1240      P:00031A P:00031A 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
1241      P:00031B P:00031B 000000            NOP
1242                                L_DAC
1243   
1244                                ; Let the DAC voltages all ramp up before exiting
1245      P:00031C P:00031C 44F400            MOVE              #400000,X0
                            061A80
1246      P:00031E P:00031E 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000320
1247      P:000320 P:000320 000000            NOP
1248      P:000321 P:000321 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1249      P:000322 P:000322 00000C            RTS
1250   
1251                                SET_BIAS_VOLTAGES
1252      P:000323 P:000323 0D030C            JSR     <SET_BIASES
1253      P:000324 P:000324 0C008F            JMP     <FINISH
1254   
1255      P:000325 P:000325 0D0327  CLR_SWS   JSR     <CLEAR_SWITCHES
1256      P:000326 P:000326 0C008F            JMP     <FINISH
1257   
1258                                ; Clear all video processor analog switches to lower their power dissipation
1259                                CLEAR_SWITCHES
1260      P:000327 P:000327 012F23            BSET    #3,X:PCRD                         ; Turn the serial clock on
1261      P:000328 P:000328 56F400            MOVE              #$0C3000,A              ; Value of integrate speed and gain switches
                            0C3000
1262      P:00032A P:00032A 20001B            CLR     B
1263      P:00032B P:00032B 241000            MOVE              #$100000,X0             ; Increment over board numbers for DAC write
s
1264      P:00032C P:00032C 45F400            MOVE              #$001000,X1             ; Increment over board numbers for WRSS writ
es
                            001000
1265      P:00032E P:00032E 060F80            DO      #15,L_VIDEO                       ; Fifteen video processor boards maximum
                            000335
1266      P:000330 P:000330 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
1267      P:000331 P:000331 200040            ADD     X0,A
1268      P:000332 P:000332 5F7000            MOVE                          B,Y:WRSS
                            FFFFF3
1269      P:000334 P:000334 0D0416            JSR     <PAL_DLY                          ; Delay for the serial data transmission
1270      P:000335 P:000335 200068            ADD     X1,B
1271                                L_VIDEO
1272      P:000336 P:000336 0A0F00            BCLR    #CDAC,X:<LATCH                    ; Enable clearing of DACs
1273      P:000337 P:000337 0A0F02            BCLR    #ENCK,X:<LATCH                    ; Disable clock and DAC output switches
1274      P:000338 P:000338 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Execute these two operations
                            00000F
1275      P:00033A P:00033A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1276      P:00033B P:00033B 00000C            RTS
1277   
1278                                SET_SHUTTER_STATE
1279      P:00033C P:00033C 568F00            MOVE              X:LATCH,A
1280      P:00033D P:00033D 0140C6            AND     #$FFEF,A
                            00FFEF
1281      P:00033F P:00033F 200042            OR      X0,A
1282      P:000340 P:000340 000000            NOP
1283      P:000341 P:000341 540F00            MOVE              A1,X:LATCH
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 24



1284      P:000342 P:000342 09CC35            MOVEP             A1,Y:WRLATCH
1285      P:000343 P:000343 00000C            RTS
1286   
1287                                ; Open the shutter from the timing board, executed as a command
1288                                OPEN_SHUTTER
1289      P:000344 P:000344 0A0023            BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
1290      P:000345 P:000345 240000            MOVE              #0,X0
1291      P:000346 P:000346 0D033C            JSR     <SET_SHUTTER_STATE
1292      P:000347 P:000347 0C008F            JMP     <FINISH
1293   
1294                                ; Close the shutter from the timing board, executed as a command
1295                                CLOSE_SHUTTER
1296      P:000348 P:000348 0A0003            BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1297      P:000349 P:000349 44F400            MOVE              #>$10,X0
                            000010
1298      P:00034B P:00034B 0D033C            JSR     <SET_SHUTTER_STATE
1299      P:00034C P:00034C 0C008F            JMP     <FINISH
1300   
1301                                ; Shutter subroutines
1302      P:00034D P:00034D 0A0023  OSHUT     BSET    #ST_SHUT,X:<STATUS                ; Set status bit to mean shutter open
1303      P:00034E P:00034E 240000            MOVE              #0,X0
1304      P:00034F P:00034F 0D033C            JSR     <SET_SHUTTER_STATE
1305      P:000350 P:000350 00000C            RTS
1306   
1307      P:000351 P:000351 0A0003  CSHUT     BCLR    #ST_SHUT,X:<STATUS                ; Clear status to mean shutter closed
1308      P:000352 P:000352 44F400            MOVE              #>$10,X0
                            000010
1309      P:000354 P:000354 0D033C            JSR     <SET_SHUTTER_STATE
1310      P:000355 P:000355 00000C            RTS
1311   
1312                                ; Clear the CCD, executed as a command
1313      P:000356 P:000356 0D0358  CLEAR     JSR     <CLR_CCD
1314      P:000357 P:000357 0C008F            JMP     <FINISH
1315   
1316                                ; Default clearing routine with serial clocks inactive
1317                                ; Fast clear image before each exposure, executed as a subroutine
1318      P:000358 P:000358 060440  CLR_CCD   DO      Y:<NPCLR,LPCLR2                   ; Loop over number of lines in image
                            000368
1319      P:00035A P:00035A 689100            MOVE                          Y:<PARALLEL_CLEAR,R0 ; Address of parallel transfer wave
form
1320                                          CLOCK
1324      P:00035F P:00035F 0A8989            JCLR    #EF,X:HDR,LPCLR1                  ; Simple test for fast execution
                            000368
1325      P:000361 P:000361 330700            MOVE              #COM_BUF,R3
1326      P:000362 P:000362 0D00A5            JSR     <GET_RCV                          ; Check for FO command
1327      P:000363 P:000363 0E0368            JCC     <LPCLR1                           ; Continue no commands received
1328   
1329      P:000364 P:000364 60F400            MOVE              #LPCLR1,R0
                            000368
1330      P:000366 P:000366 601F00            MOVE              R0,X:<IDL_ADR
1331      P:000367 P:000367 0C005D            JMP     <PRC_RCV
1332      P:000368 P:000368 000000  LPCLR1    NOP
1333                                LPCLR2
1334      P:000369 P:000369 330700            MOVE              #COM_BUF,R3
1335      P:00036A P:00036A 0D00A5            JSR     <GET_RCV                          ; Check for FO command
1336      P:00036B P:00036B 00000C            RTS
1337   
1338                                ; Start the exposure timer and monitor its progress
1339      P:00036C P:00036C 07F40E  EXPOSE    MOVEP             #0,X:TLR0               ; Load 0 into counter timer
                            000000
1340      P:00036E P:00036E 240000            MOVE              #0,X0
1341      P:00036F P:00036F 441100            MOVE              X0,X:<ELAPSED_TIME      ; Set elapsed exposure time to zero
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 25



1342      P:000370 P:000370 579000            MOVE              X:<EXPOSURE_TIME,B
1343      P:000371 P:000371 20000B            TST     B                                 ; Special test for zero exposure time
1344      P:000372 P:000372 0EA37E            JEQ     <END_EXP                          ; Don't even start an exposure
1345      P:000373 P:000373 01418C            SUB     #1,B                              ; Timer counts from X:TCPR0+1 to zero
1346      P:000374 P:000374 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Enable the timer #0
1347      P:000375 P:000375 577000            MOVE              B,X:TCPR0
                            FFFF8D
1348      P:000377 P:000377 0A8989  CHK_RCV   JCLR    #EF,X:HDR,CHK_TIM                 ; Simple test for fast execution
                            00037C
1349      P:000379 P:000379 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1350      P:00037A P:00037A 0D00A5            JSR     <GET_RCV                          ; Check for an incoming command
1351      P:00037B P:00037B 0E805D            JCS     <PRC_RCV                          ; If command is received, go check it
1352      P:00037C P:00037C 018F95  CHK_TIM   JCLR    #TCF,X:TCSR0,CHK_RCV              ; Wait for timer to equal compare value
                            000377
1353      P:00037E P:00037E 010F00  END_EXP   BCLR    #TIM_BIT,X:TCSR0                  ; Disable the timer
1354      P:00037F P:00037F 0AE780            JMP     (R7)                              ; This contains the return address
1355   
1356                                ; Start the exposure, operate the shutter, and initiate the CCD readout
1357                                START_EXPOSURE
1358      P:000380 P:000380 57F400            MOVE              #$020102,B
                            020102
1359      P:000382 P:000382 0D00EB            JSR     <XMT_WRD
1360      P:000383 P:000383 57F400            MOVE              #'IIA',B                ; Initialize the PCI image address
                            494941
1361      P:000385 P:000385 0D00EB            JSR     <XMT_WRD
1362      P:000386 P:000386 0B0088            JSCLR   #NOT_CLR,X:STATUS,CLR_CCD         ; Jump to clear out routine if bit set
                            000358
1363      P:000388 P:000388 330700            MOVE              #COM_BUF,R3             ; The beginning of the command buffer
1364      P:000389 P:000389 0D00A5            JSR     <GET_RCV                          ; Check for FO command
1365      P:00038A P:00038A 0E805D            JCS     <PRC_RCV                          ; Process the command
1366      P:00038B P:00038B 305A00            MOVE              #TST_RCV,R0             ; Process commands during the exposure
1367      P:00038C P:00038C 601F00            MOVE              R0,X:<IDL_ADR
1368      P:00038D P:00038D 0D0413            JSR     <WAIT_TO_FINISH_CLOCKING
1369   
1370                                ; Operate the shutter if needed and begin exposure
1371      P:00038E P:00038E 0A008B            JCLR    #SHUT,X:STATUS,L_SEX0
                            000391
1372      P:000390 P:000390 0D034D            JSR     <OSHUT                            ; Open the shutter if needed
1373      P:000391 P:000391 67F400  L_SEX0    MOVE              #L_SEX1,R7              ; Return address at end of exposure
                            000394
1374      P:000393 P:000393 0C036C            JMP     <EXPOSE                           ; Delay for specified exposure time
1375                                L_SEX1
1376   
1377                                ; Now we really start the CCD readout, alerting the PCI board, closing the
1378                                ;  shutter, waiting for it to close and then reading out
1379      P:000394 P:000394 0D0406  STR_RDC   JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
1380      P:000395 P:000395 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
1381      P:000396 P:000396 0A008B            JCLR    #SHUT,X:STATUS,TST_SYN
                            000399
1382      P:000398 P:000398 0D0351            JSR     <CSHUT                            ; Close the shutter if necessary
1383      P:000399 P:000399 0A00AA  TST_SYN   JSET    #TST_IMG,X:STATUS,SYNTHETIC_IMAGE
                            0003D0
1384   
1385                                ; Delay readout until the shutter has fully closed
1386      P:00039B P:00039B 5E8800            MOVE                          Y:<SHDEL,A
1387      P:00039C P:00039C 200003            TST     A
1388      P:00039D P:00039D 0EF3A6            JLE     <S_DEL0
1389      P:00039E P:00039E 44F400            MOVE              #100000,X0
                            0186A0
1390      P:0003A0 P:0003A0 06CE00            DO      A,S_DEL0                          ; Delay by Y:SHDEL milliseconds
                            0003A5
1391      P:0003A2 P:0003A2 06C400            DO      X0,S_DEL1
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 26



                            0003A4
1392      P:0003A4 P:0003A4 000000            NOP
1393      P:0003A5 P:0003A5 000000  S_DEL1    NOP
1394      P:0003A6 P:0003A6 000000  S_DEL0    NOP
1395   
1396      P:0003A7 P:0003A7 0C024E            JMP     <RDCCD                            ; Finally, go read out the CCD
1397   
1398   
1399   
1400   
1401                                ; Set the desired exposure time
1402                                SET_EXPOSURE_TIME
1403      P:0003A8 P:0003A8 46DB00            MOVE              X:(R3)+,Y0
1404      P:0003A9 P:0003A9 461000            MOVE              Y0,X:EXPOSURE_TIME
1405      P:0003AA P:0003AA 04C68D            MOVEP             Y0,X:TCPR0
1406      P:0003AB P:0003AB 0C008F            JMP     <FINISH
1407   
1408                                ; Read the time remaining until the exposure ends
1409                                READ_EXPOSURE_TIME
1410      P:0003AC P:0003AC 018FA0            JSET    #TIM_BIT,X:TCSR0,RD_TIM           ; Read DSP timer if its running
                            0003B0
1411      P:0003AE P:0003AE 479100            MOVE              X:<ELAPSED_TIME,Y1
1412      P:0003AF P:0003AF 0C0090            JMP     <FINISH1
1413      P:0003B0 P:0003B0 47F000  RD_TIM    MOVE              X:TCR0,Y1               ; Read elapsed exposure time
                            FFFF8C
1414      P:0003B2 P:0003B2 0C0090            JMP     <FINISH1
1415   
1416                                ; Pause the exposure - close the shutter and stop the timer
1417                                PAUSE_EXPOSURE
1418      P:0003B3 P:0003B3 07700C            MOVEP             X:TCR0,X:ELAPSED_TIME   ; Save the elapsed exposure time
                            000011
1419      P:0003B5 P:0003B5 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
1420      P:0003B6 P:0003B6 0D0351            JSR     <CSHUT                            ; Close the shutter
1421      P:0003B7 P:0003B7 0C008F            JMP     <FINISH
1422   
1423                                ; Resume the exposure - open the shutter if needed and restart the timer
1424                                RESUME_EXPOSURE
1425      P:0003B8 P:0003B8 010F29            BSET    #TRM,X:TCSR0                      ; To be sure it will load TLR0
1426      P:0003B9 P:0003B9 07700C            MOVEP             X:TCR0,X:TLR0           ; Restore elapsed exposure time
                            FFFF8E
1427      P:0003BB P:0003BB 010F20            BSET    #TIM_BIT,X:TCSR0                  ; Re-enable the DSP exposure timer
1428      P:0003BC P:0003BC 0A008B            JCLR    #SHUT,X:STATUS,L_RES
                            0003BF
1429      P:0003BE P:0003BE 0D034D            JSR     <OSHUT                            ; Open the shutter if necessary
1430      P:0003BF P:0003BF 0C008F  L_RES     JMP     <FINISH
1431   
1432                                ; Abort exposure - close the shutter, stop the timer and resume idle mode
1433                                ABORT_EXPOSURE
1434      P:0003C0 P:0003C0 0D0351            JSR     <CSHUT                            ; Close the shutter
1435      P:0003C1 P:0003C1 010F00            BCLR    #TIM_BIT,X:TCSR0                  ; Disable the DSP exposure timer
1436      P:0003C2 P:0003C2 0A0082            JCLR    #IDLMODE,X:<STATUS,NO_IDL2        ; Don't idle after readout
                            0003C8
1437      P:0003C4 P:0003C4 60F400            MOVE              #IDLE,R0
                            000233
1438      P:0003C6 P:0003C6 601F00            MOVE              R0,X:<IDL_ADR
1439      P:0003C7 P:0003C7 0C03CA            JMP     <RDC_E2
1440      P:0003C8 P:0003C8 305A00  NO_IDL2   MOVE              #TST_RCV,R0
1441      P:0003C9 P:0003C9 601F00            MOVE              R0,X:<IDL_ADR
1442      P:0003CA P:0003CA 0D0413  RDC_E2    JSR     <WAIT_TO_FINISH_CLOCKING
1443      P:0003CB P:0003CB 0A0004            BCLR    #ST_RDC,X:<STATUS                 ; Set status to not reading out
1444      P:0003CC P:0003CC 06A08F            DO      #4000,*+3                         ; Wait 40 microsec for the fiber
                            0003CE
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 27



1445      P:0003CE P:0003CE 000000            NOP                                       ;  optic to clear out
1446      P:0003CF P:0003CF 0C008F            JMP     <FINISH
1447                                ; Generate a synthetic image by simply incrementing the pixel counts
1448                                SYNTHETIC_IMAGE
1449      P:0003D0 P:0003D0 0D0406            JSR     <PCI_READ_IMAGE                   ; Get the PCI board reading the image
1450      P:0003D1 P:0003D1 0A0024            BSET    #ST_RDC,X:<STATUS                 ; Set status to reading out
1451      P:0003D2 P:0003D2 0D0416            JSR     <PAL_DLY
1452      P:0003D3 P:0003D3 200013            CLR     A
1453      P:0003D4 P:0003D4 060240            DO      Y:<NPR,LPR_TST                    ; Loop over each line readout
                            0003DF
1454      P:0003D6 P:0003D6 060140            DO      Y:<NSR,LSR_TST                    ; Loop over number of pixels per line
                            0003DE
1455      P:0003D8 P:0003D8 0614A0            REP     #20                               ; #20 => 1.0 microsec per pixel
1456      P:0003D9 P:0003D9 000000            NOP
1457      P:0003DA P:0003DA 014180            ADD     #1,A                              ; Pixel data = Pixel data + 1
1458      P:0003DB P:0003DB 000000            NOP
1459      P:0003DC P:0003DC 21CF00            MOVE              A,B
1460      P:0003DD P:0003DD 0D03E1            JSR     <XMT_PIX                          ;  transmit them
1461      P:0003DE P:0003DE 000000            NOP
1462                                LSR_TST
1463      P:0003DF P:0003DF 000000            NOP
1464                                LPR_TST
1465      P:0003E0 P:0003E0 0C02D4            JMP     <RDC_END                          ; Normal exit
1466   
1467                                ; Transmit the 16-bit pixel datum in B1 to the host computer
1468      P:0003E1 P:0003E1 0C1DA1  XMT_PIX   ASL     #16,B,B
1469      P:0003E2 P:0003E2 000000            NOP
1470      P:0003E3 P:0003E3 216500            MOVE              B2,X1
1471      P:0003E4 P:0003E4 0C1D91            ASL     #8,B,B
1472      P:0003E5 P:0003E5 000000            NOP
1473      P:0003E6 P:0003E6 216400            MOVE              B2,X0
1474      P:0003E7 P:0003E7 000000            NOP
1475      P:0003E8 P:0003E8 09C532            MOVEP             X1,Y:WRFO
1476      P:0003E9 P:0003E9 09C432            MOVEP             X0,Y:WRFO
1477      P:0003EA P:0003EA 00000C            RTS
1478   
1479                                ; Test the hardware to read A/D values directly into the DSP instead
1480                                ;   of using the SXMIT option, A/Ds #2 and 3.
1481      P:0003EB P:0003EB 57F000  READ_AD   MOVE              X:(RDAD+2),B
                            010002
1482      P:0003ED P:0003ED 0C1DA1            ASL     #16,B,B
1483      P:0003EE P:0003EE 000000            NOP
1484      P:0003EF P:0003EF 216500            MOVE              B2,X1
1485      P:0003F0 P:0003F0 0C1D91            ASL     #8,B,B
1486      P:0003F1 P:0003F1 000000            NOP
1487      P:0003F2 P:0003F2 216400            MOVE              B2,X0
1488      P:0003F3 P:0003F3 000000            NOP
1489      P:0003F4 P:0003F4 09C532            MOVEP             X1,Y:WRFO
1490      P:0003F5 P:0003F5 09C432            MOVEP             X0,Y:WRFO
1491      P:0003F6 P:0003F6 060AA0            REP     #10
1492      P:0003F7 P:0003F7 000000            NOP
1493      P:0003F8 P:0003F8 57F000            MOVE              X:(RDAD+3),B
                            010003
1494      P:0003FA P:0003FA 0C1DA1            ASL     #16,B,B
1495      P:0003FB P:0003FB 000000            NOP
1496      P:0003FC P:0003FC 216500            MOVE              B2,X1
1497      P:0003FD P:0003FD 0C1D91            ASL     #8,B,B
1498      P:0003FE P:0003FE 000000            NOP
1499      P:0003FF P:0003FF 216400            MOVE              B2,X0
1500      P:000400 P:000400 000000            NOP
1501      P:000401 P:000401 09C532            MOVEP             X1,Y:WRFO
1502      P:000402 P:000402 09C432            MOVEP             X0,Y:WRFO
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 28



1503      P:000403 P:000403 060AA0            REP     #10
1504      P:000404 P:000404 000000            NOP
1505      P:000405 P:000405 00000C            RTS
1506   
1507                                ; Alert the PCI interface board that images are coming soon
1508                                PCI_READ_IMAGE
1509      P:000406 P:000406 57F400            MOVE              #$020104,B              ; Send header word to the FO xmtr
                            020104
1510      P:000408 P:000408 0D00EB            JSR     <XMT_WRD
1511      P:000409 P:000409 57F400            MOVE              #'RDA',B
                            524441
1512      P:00040B P:00040B 0D00EB            JSR     <XMT_WRD
1513      P:00040C P:00040C 5FF000            MOVE                          Y:NSR,B     ; Number of columns to read
                            000001
1514      P:00040E P:00040E 0D00EB            JSR     <XMT_WRD
1515      P:00040F P:00040F 5FF000            MOVE                          Y:NPR,B     ; Number of rows to read
                            000002
1516      P:000411 P:000411 0D00EB            JSR     <XMT_WRD
1517      P:000412 P:000412 00000C            RTS
1518   
1519                                ; Wait for the clocking to be complete before proceeding
1520                                WAIT_TO_FINISH_CLOCKING
1521      P:000413 P:000413 01ADA1            JSET    #SSFEF,X:PDRD,*                   ; Wait for the SS FIFO to be empty
                            000413
1522      P:000415 P:000415 00000C            RTS
1523   
1524                                ; Delay for serial writes to the PALs and DACs by 8 microsec
1525      P:000416 P:000416 062083  PAL_DLY   DO      #800,*+3                          ; Wait 8 usec for serial data xmit
                            000418
1526      P:000418 P:000418 000000            NOP
1527      P:000419 P:000419 00000C            RTS
1528   
1529                                ; Let the host computer read the controller configuration
1530                                READ_CONTROLLER_CONFIGURATION
1531      P:00041A P:00041A 4F8900            MOVE                          Y:<CONFIG,Y1 ; Just transmit the configuration
1532      P:00041B P:00041B 0C0090            JMP     <FINISH1
1533   
1534                                ; Set the video processor gain and integrator speed for all video boards
1535                                ;                                         #SPEED = 0 for slow, 1 for fast
1536      P:00041C P:00041C 012F23  ST_GAIN   BSET    #3,X:PCRD                         ; Turn on the serial clock
1537      P:00041D P:00041D 56DB00            MOVE              X:(R3)+,A               ; Gain value (1,2,5 or 10)
1538      P:00041E P:00041E 44F400            MOVE              #>1,X0
                            000001
1539      P:000420 P:000420 20001B            CLR     B
1540   
1541      P:000421 P:000421 060F80            DO      #15,CHK_GAIN
                            000426
1542      P:000423 P:000423 200005            CMP     B,A
1543      P:000424 P:000424 0EA428            JEQ     <STG_A
1544      P:000425 P:000425 200048            ADD     X0,B
1545      P:000426 P:000426 000000            NOP
1546                                CHK_GAIN
1547      P:000427 P:000427 0C0435            JMP     <ERR_SGN
1548   
1549      P:000428 P:000428 5E0000  STG_A     MOVE                          A,Y:<GAIN   ; Store the GAIN value for later use
1550      P:000429 P:000429 240D00            MOVE              #$0D0000,X0
1551      P:00042A P:00042A 200042            OR      X0,A
1552      P:00042B P:00042B 000000            NOP
1553   
1554                                ; Send this same value to 15 video processor boards whether they exist or not
1555      P:00042C P:00042C 241000            MOVE              #$100000,X0             ; Increment value
1556      P:00042D P:00042D 060F80            DO      #15,STG_LOOP
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 29



                            000432
1557      P:00042F P:00042F 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
1558      P:000430 P:000430 0D0416            JSR     <PAL_DLY                          ; Wait for SSI and PAL to be empty
1559      P:000431 P:000431 200040            ADD     X0,A                              ; Increment the video processor board number
1560      P:000432 P:000432 000000            NOP
1561                                STG_LOOP
1562      P:000433 P:000433 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1563      P:000434 P:000434 0C008F            JMP     <FINISH
1564   
1565      P:000435 P:000435 56DB00  ERR_SGN   MOVE              X:(R3)+,A
1566      P:000436 P:000436 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1567      P:000437 P:000437 0C008D            JMP     <ERROR
1568   
1569                                ; Set a particular DAC numbers, for setting DC bias voltages, clock driver
1570                                ;   voltages and video processor offset
1571                                ; This is code for the ARC32 clock driver and ARC45 CCD video processor
1572                                ;
1573                                ; SBN  #BOARD  #DAC  ['CLK' or 'VID'] voltage
1574                                ;
1575                                ;                               #BOARD is from 0 to 15
1576                                ;                               #DAC number
1577                                ;                               #voltage is from 0 to 4095
1578   
1579                                SET_BIAS_NUMBER                                     ; Set bias number
1580      P:000438 P:000438 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock
1581      P:000439 P:000439 56DB00            MOVE              X:(R3)+,A               ; First argument is board number, 0 to 15
1582      P:00043A P:00043A 0614A0            REP     #20
1583      P:00043B P:00043B 200033            LSL     A
1584      P:00043C P:00043C 000000            NOP
1585      P:00043D P:00043D 21C500            MOVE              A,X1                    ; Save the board number
1586      P:00043E P:00043E 56DB00            MOVE              X:(R3)+,A               ; Second argument is DAC number
1587      P:00043F P:00043F 57E300            MOVE              X:(R3),B                ; Third argument is 'VID' or 'CLK' string
1588      P:000440 P:000440 0140CD            CMP     #'VID',B
                            564944
1589      P:000442 P:000442 0E244A            JNE     <CLK_DRV
1590      P:000443 P:000443 060EA0            REP     #14
1591      P:000444 P:000444 200033            LSL     A
1592      P:000445 P:000445 000000            NOP
1593      P:000446 P:000446 0ACC73            BSET    #19,A1                            ; Set bits to mean video processor DAC
1594      P:000447 P:000447 000000            NOP
1595      P:000448 P:000448 0ACC72            BSET    #18,A1
1596      P:000449 P:000449 0C0474            JMP     <BD_SET
1597      P:00044A P:00044A 0140CD  CLK_DRV   CMP     #'CLK',B
                            434C4B
1598      P:00044C P:00044C 0E2489            JNE     <ERR_SBN
1599   
1600                                ; For ARC32 do some trickiness to set the chip select and address bits
1601      P:00044D P:00044D 218F00            MOVE              A1,B
1602      P:00044E P:00044E 060EA0            REP     #14
1603      P:00044F P:00044F 200033            LSL     A
1604      P:000450 P:000450 240E00            MOVE              #$0E0000,X0
1605      P:000451 P:000451 200046            AND     X0,A
1606      P:000452 P:000452 44F400            MOVE              #>7,X0
                            000007
1607      P:000454 P:000454 20004E            AND     X0,B                              ; Get 3 least significant bits of clock #
1608      P:000455 P:000455 01408D            CMP     #0,B
1609      P:000456 P:000456 0E2459            JNE     <CLK_1
1610      P:000457 P:000457 0ACE68            BSET    #8,A
1611      P:000458 P:000458 0C0474            JMP     <BD_SET
1612      P:000459 P:000459 01418D  CLK_1     CMP     #1,B
1613      P:00045A P:00045A 0E245D            JNE     <CLK_2
1614      P:00045B P:00045B 0ACE69            BSET    #9,A
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 30



1615      P:00045C P:00045C 0C0474            JMP     <BD_SET
1616      P:00045D P:00045D 01428D  CLK_2     CMP     #2,B
1617      P:00045E P:00045E 0E2461            JNE     <CLK_3
1618      P:00045F P:00045F 0ACE6A            BSET    #10,A
1619      P:000460 P:000460 0C0474            JMP     <BD_SET
1620      P:000461 P:000461 01438D  CLK_3     CMP     #3,B
1621      P:000462 P:000462 0E2465            JNE     <CLK_4
1622      P:000463 P:000463 0ACE6B            BSET    #11,A
1623      P:000464 P:000464 0C0474            JMP     <BD_SET
1624      P:000465 P:000465 01448D  CLK_4     CMP     #4,B
1625      P:000466 P:000466 0E2469            JNE     <CLK_5
1626      P:000467 P:000467 0ACE6D            BSET    #13,A
1627      P:000468 P:000468 0C0474            JMP     <BD_SET
1628      P:000469 P:000469 01458D  CLK_5     CMP     #5,B
1629      P:00046A P:00046A 0E246D            JNE     <CLK_6
1630      P:00046B P:00046B 0ACE6E            BSET    #14,A
1631      P:00046C P:00046C 0C0474            JMP     <BD_SET
1632      P:00046D P:00046D 01468D  CLK_6     CMP     #6,B
1633      P:00046E P:00046E 0E2471            JNE     <CLK_7
1634      P:00046F P:00046F 0ACE6F            BSET    #15,A
1635      P:000470 P:000470 0C0474            JMP     <BD_SET
1636      P:000471 P:000471 01478D  CLK_7     CMP     #7,B
1637      P:000472 P:000472 0E2474            JNE     <BD_SET
1638      P:000473 P:000473 0ACE70            BSET    #16,A
1639   
1640      P:000474 P:000474 200062  BD_SET    OR      X1,A                              ; Add on the board number
1641      P:000475 P:000475 000000            NOP
1642      P:000476 P:000476 21C400            MOVE              A,X0
1643      P:000477 P:000477 57DB00            MOVE              X:(R3)+,B               ; Third argument (again) is 'VID' or 'CLK' s
tring
1644      P:000478 P:000478 0140CD            CMP     #'VID',B
                            564944
1645      P:00047A P:00047A 0EA483            JEQ     <VID
1646      P:00047B P:00047B 56DB00            MOVE              X:(R3)+,A               ; Fourth argument is voltage value, 0 to $ff
f
1647      P:00047C P:00047C 0604A0            REP     #4
1648      P:00047D P:00047D 200023            LSR     A                                 ; Convert 12 bits to 8 bits for ARC32
1649      P:00047E P:00047E 46F400            MOVE              #>$FF,Y0                ; Mask off just 8 bits
                            0000FF
1650      P:000480 P:000480 200056            AND     Y0,A
1651      P:000481 P:000481 200042            OR      X0,A
1652      P:000482 P:000482 0C0485            JMP     <XMT_SBN
1653      P:000483 P:000483 56DB00  VID       MOVE              X:(R3)+,A               ; Fourth argument is voltage value for ARC45
, 12 bits
1654      P:000484 P:000484 200042            OR      X0,A
1655   
1656      P:000485 P:000485 0D020C  XMT_SBN   JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
1657      P:000486 P:000486 0D0416            JSR     <PAL_DLY                          ; Wait for the number to be sent
1658      P:000487 P:000487 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1659      P:000488 P:000488 0C008F            JMP     <FINISH
1660      P:000489 P:000489 56DB00  ERR_SBN   MOVE              X:(R3)+,A               ; Read and discard the fourth argument
1661      P:00048A P:00048A 012F03            BCLR    #3,X:PCRD                         ; Turn the serial clock off
1662      P:00048B P:00048B 0C008D            JMP     <ERROR
1663   
1664   
1665                                ; Specify the MUX value to be output on the clock driver board
1666                                ; Command syntax is  SMX  #clock_driver_board #MUX1 #MUX2
1667                                ;                               #clock_driver_board from 0 to 15
1668                                ;                               #MUX1, #MUX2 from 0 to 23
1669   
1670      P:00048C P:00048C 012F23  SET_MUX   BSET    #3,X:PCRD                         ; Turn on the serial clock
1671      P:00048D P:00048D 56DB00            MOVE              X:(R3)+,A               ; Clock driver board number
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 31



1672      P:00048E P:00048E 0614A0            REP     #20
1673      P:00048F P:00048F 200033            LSL     A
1674      P:000490 P:000490 44F400            MOVE              #$003000,X0
                            003000
1675      P:000492 P:000492 200042            OR      X0,A
1676      P:000493 P:000493 000000            NOP
1677      P:000494 P:000494 21C500            MOVE              A,X1                    ; Move here for storage
1678   
1679                                ; Get the first MUX number
1680      P:000495 P:000495 56DB00            MOVE              X:(R3)+,A               ; Get the first MUX number
1681      P:000496 P:000496 0AF0A9            JLT     ERR_SM1
                            0004DA
1682      P:000498 P:000498 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
1683      P:00049A P:00049A 200045            CMP     X0,A
1684      P:00049B P:00049B 0AF0A1            JGE     ERR_SM1
                            0004DA
1685      P:00049D P:00049D 21CF00            MOVE              A,B
1686      P:00049E P:00049E 44F400            MOVE              #>7,X0
                            000007
1687      P:0004A0 P:0004A0 20004E            AND     X0,B
1688      P:0004A1 P:0004A1 44F400            MOVE              #>$18,X0
                            000018
1689      P:0004A3 P:0004A3 200046            AND     X0,A
1690      P:0004A4 P:0004A4 0E24A7            JNE     <SMX_1                            ; Test for 0 <= MUX number <= 7
1691      P:0004A5 P:0004A5 0ACD63            BSET    #3,B1
1692      P:0004A6 P:0004A6 0C04B2            JMP     <SMX_A
1693      P:0004A7 P:0004A7 44F400  SMX_1     MOVE              #>$08,X0
                            000008
1694      P:0004A9 P:0004A9 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1695      P:0004AA P:0004AA 0E24AD            JNE     <SMX_2
1696      P:0004AB P:0004AB 0ACD64            BSET    #4,B1
1697      P:0004AC P:0004AC 0C04B2            JMP     <SMX_A
1698      P:0004AD P:0004AD 44F400  SMX_2     MOVE              #>$10,X0
                            000010
1699      P:0004AF P:0004AF 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1700      P:0004B0 P:0004B0 0E24DA            JNE     <ERR_SM1
1701      P:0004B1 P:0004B1 0ACD65            BSET    #5,B1
1702      P:0004B2 P:0004B2 20006A  SMX_A     OR      X1,B1                             ; Add prefix to MUX numbers
1703      P:0004B3 P:0004B3 000000            NOP
1704      P:0004B4 P:0004B4 21A700            MOVE              B1,Y1
1705   
1706                                ; Add on the second MUX number
1707      P:0004B5 P:0004B5 56DB00            MOVE              X:(R3)+,A               ; Get the next MUX number
1708      P:0004B6 P:0004B6 0E908D            JLT     <ERROR
1709      P:0004B7 P:0004B7 44F400            MOVE              #>24,X0                 ; Check for argument less than 32
                            000018
1710      P:0004B9 P:0004B9 200045            CMP     X0,A
1711      P:0004BA P:0004BA 0E108D            JGE     <ERROR
1712      P:0004BB P:0004BB 0606A0            REP     #6
1713      P:0004BC P:0004BC 200033            LSL     A
1714      P:0004BD P:0004BD 000000            NOP
1715      P:0004BE P:0004BE 21CF00            MOVE              A,B
1716      P:0004BF P:0004BF 44F400            MOVE              #$1C0,X0
                            0001C0
1717      P:0004C1 P:0004C1 20004E            AND     X0,B
1718      P:0004C2 P:0004C2 44F400            MOVE              #>$600,X0
                            000600
1719      P:0004C4 P:0004C4 200046            AND     X0,A
1720      P:0004C5 P:0004C5 0E24C8            JNE     <SMX_3                            ; Test for 0 <= MUX number <= 7
1721      P:0004C6 P:0004C6 0ACD69            BSET    #9,B1
1722      P:0004C7 P:0004C7 0C04D3            JMP     <SMX_B
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 32



1723      P:0004C8 P:0004C8 44F400  SMX_3     MOVE              #>$200,X0
                            000200
1724      P:0004CA P:0004CA 200045            CMP     X0,A                              ; Test for 8 <= MUX number <= 15
1725      P:0004CB P:0004CB 0E24CE            JNE     <SMX_4
1726      P:0004CC P:0004CC 0ACD6A            BSET    #10,B1
1727      P:0004CD P:0004CD 0C04D3            JMP     <SMX_B
1728      P:0004CE P:0004CE 44F400  SMX_4     MOVE              #>$400,X0
                            000400
1729      P:0004D0 P:0004D0 200045            CMP     X0,A                              ; Test for 16 <= MUX number <= 23
1730      P:0004D1 P:0004D1 0E208D            JNE     <ERROR
1731      P:0004D2 P:0004D2 0ACD6B            BSET    #11,B1
1732      P:0004D3 P:0004D3 200078  SMX_B     ADD     Y1,B                              ; Add prefix to MUX numbers
1733      P:0004D4 P:0004D4 000000            NOP
1734      P:0004D5 P:0004D5 21AE00            MOVE              B1,A
1735      P:0004D6 P:0004D6 0D020C            JSR     <XMIT_A_WORD                      ; Transmit A to TIM-A-STD
1736      P:0004D7 P:0004D7 0D0416            JSR     <PAL_DLY                          ; Delay for all this to happen
1737      P:0004D8 P:0004D8 012F03            BCLR    #3,X:PCRD                         ; Turn off the serial clock
1738      P:0004D9 P:0004D9 0C008F            JMP     <FINISH
1739      P:0004DA P:0004DA 56DB00  ERR_SM1   MOVE              X:(R3)+,A
1740      P:0004DB P:0004DB 012F03            BCLR    #3,X:PCRD                         ; Turn off the serial clock
1741      P:0004DC P:0004DC 0C008D            JMP     <ERROR
1742   
1743                                ; Specify subarray readout coordinates, one rectangle only
1744                                SET_SUBARRAY_SIZES
1745      P:0004DD P:0004DD 200013            CLR     A
1746      P:0004DE P:0004DE 000000            NOP
1747      P:0004DF P:0004DF 5E1B00            MOVE                          A,Y:<NBOXES ; Number of subimage boxes = 0 to start
1748      P:0004E0 P:0004E0 44DB00            MOVE              X:(R3)+,X0
1749      P:0004E1 P:0004E1 4C1C00            MOVE                          X0,Y:<NR_BIAS ; Number of bias pixels to read
1750      P:0004E2 P:0004E2 44DB00            MOVE              X:(R3)+,X0
1751      P:0004E3 P:0004E3 4C1D00            MOVE                          X0,Y:<NS_READ ; Number of columns in subimage read
1752      P:0004E4 P:0004E4 44DB00            MOVE              X:(R3)+,X0
1753      P:0004E5 P:0004E5 4C1E00            MOVE                          X0,Y:<NP_READ ; Number of rows in subimage read
1754      P:0004E6 P:0004E6 0C008F            JMP     <FINISH
1755   
1756                                ; Call this routine once for every subarray to be added to the table
1757                                SET_SUBARRAY_POSITIONS
1758      P:0004E7 P:0004E7 4C9B00            MOVE                          Y:<NBOXES,X0
1759      P:0004E8 P:0004E8 459400            MOVE              X:<THREE,X1
1760      P:0004E9 P:0004E9 2000A0            MPY     X0,X1,A
1761      P:0004EA P:0004EA 200022            ASR     A
1762      P:0004EB P:0004EB 210C00            MOVE              A0,A1
1763      P:0004EC P:0004EC 44F400            MOVE              #>10,X0
                            00000A
1764      P:0004EE P:0004EE 200045            CMP     X0,A
1765      P:0004EF P:0004EF 0E708D            JGT     <ERROR                            ; Error if number of boxes > 10
1766      P:0004F0 P:0004F0 44F400            MOVE              #READ_TABLE,X0
                            00001F
1767      P:0004F2 P:0004F2 200040            ADD     X0,A
1768      P:0004F3 P:0004F3 000000            NOP
1769      P:0004F4 P:0004F4 219700            MOVE              A1,R7
1770      P:0004F5 P:0004F5 44DB00            MOVE              X:(R3)+,X0
1771      P:0004F6 P:0004F6 000000            NOP
1772      P:0004F7 P:0004F7 000000            NOP
1773      P:0004F8 P:0004F8 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of rows (parallels) to clear
1774      P:0004F9 P:0004F9 44DB00            MOVE              X:(R3)+,X0
1775      P:0004FA P:0004FA 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears before
1776      P:0004FB P:0004FB 44DB00            MOVE              X:(R3)+,X0              ;  the box readout
1777      P:0004FC P:0004FC 4C5F00            MOVE                          X0,Y:(R7)+  ; Number of columns (serials) clears after
1778      P:0004FD P:0004FD 5E9B00            MOVE                          Y:<NBOXES,A ;  the box readout
1779      P:0004FE P:0004FE 449200            MOVE              X:<ONE,X0
1780      P:0004FF P:0004FF 200040            ADD     X0,A
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 33



1781      P:000500 P:000500 000000            NOP
1782      P:000501 P:000501 5E1B00            MOVE                          A,Y:<NBOXES
1783      P:000502 P:000502 0C008F            JMP     <FINISH
1784   
1785                                ; Generate the serial readout waveform table for the chosen
1786                                ;   value of readout and serial binning.
1787   
1788                                GENERATE_SERIAL_WAVEFORM
1789      P:000503 P:000503 60F400            MOVE              #CCD_RESET,R0
                            0000C8
1790      P:000505 P:000505 61F400            MOVE              #(PXL_TBL+1),R1
                            0001DD
1791      P:000507 P:000507 5ED800            MOVE                          Y:(R0)+,A
1792      P:000508 P:000508 000000            NOP
1793      P:000509 P:000509 06CC00            DO      A1,L_CCD_RESET
                            00050C
1794      P:00050B P:00050B 4CD800            MOVE                          Y:(R0)+,X0
1795      P:00050C P:00050C 4C5900            MOVE                          X0,Y:(R1)+
1796                                L_CCD_RESET
1797   
1798                                ; Generate the first set of clocks
1799      P:00050D P:00050D 68F000            MOVE                          Y:FIRST_CLOCKS,R0
                            00000C
1800      P:00050F P:00050F 000000            NOP
1801      P:000510 P:000510 000000            NOP
1802      P:000511 P:000511 5ED800            MOVE                          Y:(R0)+,A
1803      P:000512 P:000512 000000            NOP
1804      P:000513 P:000513 06CC00            DO      A1,L_FIRST_CLOCKS
                            000516
1805      P:000515 P:000515 4CD800            MOVE                          Y:(R0)+,X0
1806      P:000516 P:000516 4C5900            MOVE                          X0,Y:(R1)+
1807                                L_FIRST_CLOCKS
1808   
1809   
1810                                ; Generate the binning waveforms if needed
1811      P:000517 P:000517 5E8500            MOVE                          Y:<NSBIN,A
1812      P:000518 P:000518 014184            SUB     #1,A
1813      P:000519 P:000519 0EF527            JLE     <GEN_VID
1814      P:00051A P:00051A 06CC00            DO      A1,L_BIN
                            000526
1815      P:00051C P:00051C 68F000            MOVE                          Y:CLOCK_LINE,R0
                            00000D
1816      P:00051E P:00051E 000000            NOP
1817      P:00051F P:00051F 000000            NOP
1818      P:000520 P:000520 5ED800            MOVE                          Y:(R0)+,A
1819      P:000521 P:000521 000000            NOP
1820      P:000522 P:000522 06CC00            DO      A1,L_CLOCK_LINE
                            000525
1821      P:000524 P:000524 4CD800            MOVE                          Y:(R0)+,X0
1822      P:000525 P:000525 4C5900            MOVE                          X0,Y:(R1)+
1823                                L_CLOCK_LINE
1824      P:000526 P:000526 000000            NOP
1825                                L_BIN
1826   
1827                                ; Generate the video processor waveforms
1828      P:000527 P:000527 60F400  GEN_VID   MOVE              #VIDEO_PROCESS,R0
                            0000E4
1829      P:000529 P:000529 000000            NOP
1830      P:00052A P:00052A 000000            NOP
1831      P:00052B P:00052B 5ED800            MOVE                          Y:(R0)+,A
1832      P:00052C P:00052C 000000            NOP
1833      P:00052D P:00052D 06CC00            DO      A1,L_VID
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 34



                            000530
1834      P:00052F P:00052F 4CD800            MOVE                          Y:(R0)+,X0
1835      P:000530 P:000530 4C5900            MOVE                          X0,Y:(R1)+
1836                                L_VID
1837   
1838                                ; Finally, calculate the number of entries in the waveform table just generated
1839      P:000531 P:000531 44F400            MOVE              #PXL_TBL,X0
                            0001DC
1840      P:000533 P:000533 209000            MOVE              X0,R0
1841      P:000534 P:000534 222E00            MOVE              R1,A
1842      P:000535 P:000535 200044            SUB     X0,A
1843      P:000536 P:000536 014184            SUB     #1,A
1844      P:000537 P:000537 000000            NOP
1845      P:000538 P:000538 5C6000            MOVE                          A1,Y:(R0)
1846      P:000539 P:000539 00000C            RTS
1847   
1848                                ; Select which readouts to process
1849                                ;   'SOS'  Amplifier_name
1850                                ;       Amplifier_name = '__L', '__R', or '_LR'
1851   
1852                                SELECT_OUTPUT_SOURCE
1853      P:00053A P:00053A 46DB00            MOVE              X:(R3)+,Y0
1854      P:00053B P:00053B 4E0B00            MOVE                          Y0,Y:<OS
1855      P:00053C P:00053C 0D053E            JSR     <SEL_OS
1856      P:00053D P:00053D 0C008F            JMP     <FINISH
1857   
1858      P:00053E P:00053E 4E8B00  SEL_OS    MOVE                          Y:<OS,Y0
1859      P:00053F P:00053F 56F400            MOVE              #'_U1',A
                            5F5531
1860      P:000541 P:000541 200055            CMP     Y0,A
1861      P:000542 P:000542 0E255E            JNE     <COMP_U2
1862   
1863      P:000543 P:000543 44F400            MOVE              #$F0C3,X0
                            00F0C3
1864      P:000545 P:000545 4C7000            MOVE                          X0,Y:SXL
                            0000F6
1865      P:000547 P:000547 44F400            MOVE              #PARALLEL_1,X0
                            000034
1866      P:000549 P:000549 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1867      P:00054B P:00054B 44F400            MOVE              #SERIAL_READ_LEFT,X0
                            0000ED
1868      P:00054D P:00054D 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1869      P:00054F P:00054F 44F400            MOVE              #SERIAL_SKIP_LEFT,X0
                            000123
1870      P:000551 P:000551 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1871      P:000553 P:000553 44F400            MOVE              #SERIAL_IDLE_LEFT,X0
                            00005C
1872      P:000555 P:000555 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1873      P:000557 P:000557 44F400            MOVE              #PARALLEL_CLEAR_1,X0
                            00003E
1874      P:000559 P:000559 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1875      P:00055B P:00055B 0A0005            BCLR    #SPLIT_S,X:STATUS
1876      P:00055C P:00055C 0A0006            BCLR    #SPLIT_P,X:STATUS
1877      P:00055D P:00055D 00000C            RTS
1878   
1879      P:00055E P:00055E 56F400  COMP_U2   MOVE              #'_U2',A
                            5F5532
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 35



1880      P:000560 P:000560 200055            CMP     Y0,A
1881      P:000561 P:000561 0E257D            JNE     <COMP_L1
1882   
1883      P:000562 P:000562 44F400            MOVE              #$F041,X0
                            00F041
1884      P:000564 P:000564 4C7000            MOVE                          X0,Y:SXR
                            00011A
1885      P:000566 P:000566 44F400            MOVE              #PARALLEL_2,X0
                            00002B
1886      P:000568 P:000568 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1887      P:00056A P:00056A 44F400            MOVE              #SERIAL_READ_RIGHT,X0
                            000111
1888      P:00056C P:00056C 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1889      P:00056E P:00056E 44F400            MOVE              #SERIAL_SKIP_RIGHT,X0
                            00012C
1890      P:000570 P:000570 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1891      P:000572 P:000572 44F400            MOVE              #SERIAL_IDLE_RIGHT,X0
                            000080
1892      P:000574 P:000574 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1893      P:000576 P:000576 44F400            MOVE              #PARALLEL_CLEAR_2,X0
                            000048
1894      P:000578 P:000578 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1895      P:00057A P:00057A 0A0005            BCLR    #SPLIT_S,X:STATUS
1896      P:00057B P:00057B 0A0006            BCLR    #SPLIT_P,X:STATUS
1897      P:00057C P:00057C 00000C            RTS
1898   
1899      P:00057D P:00057D 56F400  COMP_L1   MOVE              #'_L1',A
                            5F4C31
1900      P:00057F P:00057F 200055            CMP     Y0,A
1901      P:000580 P:000580 0E259C            JNE     <COMP_L2
1902   
1903   
1904      P:000581 P:000581 44F400            MOVE              #$F082,X0
                            00F082
1905      P:000583 P:000583 4C7000            MOVE                          X0,Y:SXR
                            00011A
1906      P:000585 P:000585 44F400            MOVE              #PARALLEL_1,X0
                            000034
1907      P:000587 P:000587 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1908      P:000589 P:000589 44F400            MOVE              #SERIAL_READ_RIGHT,X0
                            000111
1909      P:00058B P:00058B 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1910      P:00058D P:00058D 44F400            MOVE              #SERIAL_SKIP_RIGHT,X0
                            00012C
1911      P:00058F P:00058F 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1912      P:000591 P:000591 44F400            MOVE              #SERIAL_IDLE_RIGHT,X0
                            000080
1913      P:000593 P:000593 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1914      P:000595 P:000595 44F400            MOVE              #PARALLEL_CLEAR_1,X0
                            00003E
1915      P:000597 P:000597 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1916      P:000599 P:000599 0A0005            BCLR    #SPLIT_S,X:STATUS
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 36



1917      P:00059A P:00059A 0A0006            BCLR    #SPLIT_P,X:STATUS
1918      P:00059B P:00059B 00000C            RTS
1919   
1920      P:00059C P:00059C 56F400  COMP_L2   MOVE              #'_L2',A
                            5F4C32
1921      P:00059E P:00059E 200055            CMP     Y0,A
1922      P:00059F P:00059F 0E25BB            JNE     <COMP_2
1923   
1924      P:0005A0 P:0005A0 44F400            MOVE              #$F000,X0
                            00F000
1925      P:0005A2 P:0005A2 4C7000            MOVE                          X0,Y:SXL
                            0000F6
1926      P:0005A4 P:0005A4 44F400            MOVE              #PARALLEL_2,X0
                            00002B
1927      P:0005A6 P:0005A6 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1928      P:0005A8 P:0005A8 44F400            MOVE              #SERIAL_READ_LEFT,X0
                            0000ED
1929      P:0005AA P:0005AA 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1930      P:0005AC P:0005AC 44F400            MOVE              #SERIAL_SKIP_LEFT,X0
                            000123
1931      P:0005AE P:0005AE 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1932      P:0005B0 P:0005B0 44F400            MOVE              #SERIAL_IDLE_LEFT,X0
                            00005C
1933      P:0005B2 P:0005B2 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1934      P:0005B4 P:0005B4 44F400            MOVE              #PARALLEL_CLEAR_2,X0
                            000048
1935      P:0005B6 P:0005B6 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1936      P:0005B8 P:0005B8 0A0005            BCLR    #SPLIT_S,X:STATUS
1937      P:0005B9 P:0005B9 0A0006            BCLR    #SPLIT_P,X:STATUS
1938      P:0005BA P:0005BA 00000C            RTS
1939   
1940      P:0005BB P:0005BB 56F400  COMP_2    MOVE              #'__2',A
                            5F5F32
1941      P:0005BD P:0005BD 200055            CMP     Y0,A
1942      P:0005BE P:0005BE 0E25DA            JNE     <COMP_1
1943   
1944      P:0005BF P:0005BF 44F400            MOVE              #$F040,X0
                            00F040
1945      P:0005C1 P:0005C1 4C7000            MOVE                          X0,Y:SXRL
                            000108
1946      P:0005C3 P:0005C3 44F400            MOVE              #PARALLEL_2,X0
                            00002B
1947      P:0005C5 P:0005C5 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1948      P:0005C7 P:0005C7 44F400            MOVE              #SERIAL_READ_SPLIT,X0
                            0000FF
1949      P:0005C9 P:0005C9 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1950      P:0005CB P:0005CB 44F400            MOVE              #SERIAL_SKIP_SPLIT,X0
                            000135
1951      P:0005CD P:0005CD 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1952      P:0005CF P:0005CF 44F400            MOVE              #SERIAL_IDLE_SPLIT,X0
                            0000A4
1953      P:0005D1 P:0005D1 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1954      P:0005D3 P:0005D3 44F400            MOVE              #PARALLEL_CLEAR_2,X0
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 37



                            000048
1955      P:0005D5 P:0005D5 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1956      P:0005D7 P:0005D7 0A0025            BSET    #SPLIT_S,X:STATUS
1957      P:0005D8 P:0005D8 0A0006            BCLR    #SPLIT_P,X:STATUS
1958      P:0005D9 P:0005D9 00000C            RTS
1959   
1960      P:0005DA P:0005DA 56F400  COMP_1    MOVE              #'__1',A
                            5F5F31
1961      P:0005DC P:0005DC 200055            CMP     Y0,A
1962      P:0005DD P:0005DD 0E25F9            JNE     <COMP_ALL
1963   
1964      P:0005DE P:0005DE 44F400            MOVE              #$F0C2,X0
                            00F0C2
1965      P:0005E0 P:0005E0 4C7000            MOVE                          X0,Y:SXRL
                            000108
1966      P:0005E2 P:0005E2 44F400            MOVE              #PARALLEL_1,X0
                            000034
1967      P:0005E4 P:0005E4 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1968      P:0005E6 P:0005E6 44F400            MOVE              #SERIAL_READ_SPLIT,X0
                            0000FF
1969      P:0005E8 P:0005E8 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1970      P:0005EA P:0005EA 44F400            MOVE              #SERIAL_SKIP_SPLIT,X0
                            000135
1971      P:0005EC P:0005EC 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1972      P:0005EE P:0005EE 44F400            MOVE              #SERIAL_IDLE_SPLIT,X0
                            0000A4
1973      P:0005F0 P:0005F0 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1974      P:0005F2 P:0005F2 44F400            MOVE              #PARALLEL_CLEAR_1,X0
                            00003E
1975      P:0005F4 P:0005F4 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1976      P:0005F6 P:0005F6 0A0025            BSET    #SPLIT_S,X:STATUS
1977      P:0005F7 P:0005F7 0A0006            BCLR    #SPLIT_P,X:STATUS
1978      P:0005F8 P:0005F8 00000C            RTS
1979   
1980      P:0005F9 P:0005F9 56F400  COMP_ALL  MOVE              #'ALL',A
                            414C4C
1981      P:0005FB P:0005FB 200055            CMP     Y0,A
1982      P:0005FC P:0005FC 0E208D            JNE     <ERROR
1983   
1984      P:0005FD P:0005FD 44F400            MOVE              #$F0C0,X0
                            00F0C0
1985      P:0005FF P:0005FF 4C7000            MOVE                          X0,Y:SXRL
                            000108
1986      P:000601 P:000601 44F400            MOVE              #PARALLEL_SPLIT,X0
                            000022
1987      P:000603 P:000603 4C7000            MOVE                          X0,Y:PARALLEL
                            000010
1988      P:000605 P:000605 44F400            MOVE              #SERIAL_READ_SPLIT,X0
                            0000FF
1989      P:000607 P:000607 4C7000            MOVE                          X0,Y:SERIAL_READ
                            00000E
1990      P:000609 P:000609 44F400            MOVE              #SERIAL_SKIP_SPLIT,X0
                            000135
1991      P:00060B P:00060B 4C7000            MOVE                          X0,Y:SERIAL_SKIP
                            00000F
1992      P:00060D P:00060D 44F400            MOVE              #SERIAL_IDLE_SPLIT,X0
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 38



                            0000A4
1993      P:00060F P:00060F 4C7000            MOVE                          X0,Y:SERIAL_IDLE
                            000012
1994      P:000611 P:000611 44F400            MOVE              #PARALLEL_CLEAR_SPLIT,X0
                            000052
1995      P:000613 P:000613 4C7000            MOVE                          X0,Y:PARALLEL_CLEAR
                            000011
1996      P:000615 P:000615 0A0025            BSET    #SPLIT_S,X:STATUS
1997      P:000616 P:000616 0A0026            BSET    #SPLIT_P,X:STATUS
1998      P:000617 P:000617 00000C            RTS
1999   
2000   
2001      P:000618 P:000618 44DB00  ERASE     MOVE              X:(R3)+,X0              ; Get TIME1 off the command buffer
2002      P:000619 P:000619 4C1600            MOVE                          X0,Y:<TIME1 ; Move it to the address in tim.asm
2003      P:00061A P:00061A 44DB00            MOVE              X:(R3)+,X0              ; Ditto for TIME2
2004      P:00061B P:00061B 4C1700            MOVE                          X0,Y:<TIME2
2005   
2006                                                                                    ;TODO: Get rid of this horrible hack
2007                                                                                    ;Horrible hack to get over time out on comma
nd return
2008      P:00061C P:00061C 0D0653            JSR     <HACK_FINISH
2009      P:00061D P:00061D 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock - this should alr
eady be the case
2010      P:00061E P:00061E 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
2011      P:00061F P:00061F 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
2012      P:000620 P:000620 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
2013      P:000621 P:000621 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
2014      P:000623 P:000623 0D0416            JSR     <PAL_DLY                          ; Delay for all this to happen
2015   
2016                                ; Read DAC values from a table, and write them to the DACs
2017      P:000624 P:000624 60F400            MOVE              #ERHI,R0                ; Get starting address of erase clock values
                            00013F
2018      P:000626 P:000626 000000            NOP
2019      P:000627 P:000627 000000            NOP
2020      P:000628 P:000628 065840            DO      Y:(R0)+,E_DAC                     ; Repeat Y:(R0)+ times
                            00062C
2021      P:00062A P:00062A 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2022      P:00062B P:00062B 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2023      P:00062C P:00062C 000000            NOP
2024                                E_DAC
2025   
2026                                ; Let the DAC voltages all ramp up before exiting
2027      P:00062D P:00062D 44F400            MOVE              #400000,X0
                            061A80
2028      P:00062F P:00062F 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000631
2029      P:000631 P:000631 000000            NOP
2030   
2031                                ; Start the delay loop
2032   
2033      P:000632 P:000632 061640            DO      Y:<TIME1,ER_T1                    ; Delay TIME1 msec
                            000635
2034      P:000634 P:000634 0D064D            JSR     <LNG_DLY
2035      P:000635 P:000635 000000            NOP
2036   
2037      P:000636 P:000636 5EF000  ER_T1     MOVE                          Y:VSUBN,A   ; Reset the Vsub value
                            00013E
2038      P:000638 P:000638 0D020C            JSR     <XMIT_A_WORD
2039      P:000639 P:000639 0D0416            JSR     <PAL_DLY                          ; Wait for SSI and PAL to empty
2040   
2041      P:00063A P:00063A 061740            DO      Y:<TIME2,ER_T2                    ; Delay TIME2 msec
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 39



                            00063D
2042      P:00063C P:00063C 0D064D            JSR     <LNG_DLY
2043      P:00063D P:00063D 000000            NOP
2044   
2045      P:00063E P:00063E 60F400  ER_T2     MOVE              #ERHI_END,R0            ; Get the original clock values back.
                            000159
2046                                ;        MOVE    #DACS,R0               ; This line would do the same job -- pointing back to th
e
2047                                                                                    ; original clocking values, but you'd be set
ting everything.
2048   
2049                                ; Read DAC values from a table, and write them to the DACs
2050      P:000640 P:000640 000000            NOP
2051      P:000641 P:000641 000000            NOP
2052      P:000642 P:000642 065840            DO      Y:(R0)+,END_DAC_RESTORE           ; Repeat Y:(R0)+ times
                            000646
2053      P:000644 P:000644 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2054      P:000645 P:000645 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2055      P:000646 P:000646 000000            NOP
2056                                END_DAC_RESTORE
2057   
2058                                ; Let the DAC voltages all ramp up before exiting
2059      P:000647 P:000647 44F400            MOVE              #400000,X0
                            061A80
2060      P:000649 P:000649 06C400            DO      X0,*+3                            ; 4 millisec delay
                            00064B
2061      P:00064B P:00064B 000000            NOP
2062      P:00064C P:00064C 0C0054            JMP     <START
2063   
2064                                ; Routine to delay for 1msec
2065                                ; 40ns for DO and NOP line.  1ms/80ns = 125000
2066   
2067      P:00064D P:00064D 44F400  LNG_DLY   MOVE              #100000,X0
                            0186A0
2068      P:00064F P:00064F 06C400            DO      X0,*+3                            ; Wait 1 millisec for settling
                            000651
2069      P:000651 P:000651 000000            NOP
2070      P:000652 P:000652 00000C            RTS
2071   
2072                                ; Hack finish subroutine to send 'DON' reply back to the PIC
2073                                ; card.  Some of this should be redundant -- such as jumping to the
2074                                ; command processing.
2075                                 HACK_FINISH
2076      P:000653 P:000653 479800            MOVE              X:<DONE,Y1              ; Send 'DON' as the reply
2077                                 HACK_FINISH1
2078      P:000654 P:000654 578500            MOVE              X:<HEADER,B             ; Get header of incoming command
2079      P:000655 P:000655 469C00            MOVE              X:<SMASK,Y0             ; This was the source byte, and is to
2080      P:000656 P:000656 330700            MOVE              #<COM_BUF,R3            ;     become the destination byte
2081      P:000657 P:000657 46935E            AND     Y0,B      X:<TWO,Y0
2082      P:000658 P:000658 0C1ED1            LSR     #8,B                              ; Shift right eight bytes, add it to the
2083      P:000659 P:000659 460600            MOVE              Y0,X:<NWORDS            ;     header, and put 2 as the number
2084      P:00065A P:00065A 469958            ADD     Y0,B      X:<SBRD,Y0              ;     of words in the string
2085      P:00065B P:00065B 200058            ADD     Y0,B                              ; Add source board's header, set Y1 for abov
e
2086      P:00065C P:00065C 000000            NOP
2087      P:00065D P:00065D 575B00            MOVE              B,X:(R3)+               ; Put the new header on the transmitter stac
k
2088      P:00065E P:00065E 475B00            MOVE              Y1,X:(R3)+              ; Put the argument on the transmitter stack
2089      P:00065F P:00065F 570500            MOVE              B,X:<HEADER
2090      P:000660 P:000660 330700            MOVE              #<COM_BUF,R3            ; Restore R3 = beginning of the command
2091   
2092                                ; Is this command for the timing board?
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 40



2093      P:000661 P:000661 448500            MOVE              X:<HEADER,X0
2094      P:000662 P:000662 579B00            MOVE              X:<DMASK,B
2095      P:000663 P:000663 459A4E            AND     X0,B      X:<TIM_DRB,X1           ; Extract destination byte
2096      P:000664 P:000664 20006D            CMP     X1,B                              ; Does header = timing board number?
2097      P:000665 P:000665 0EA080            JEQ     <COMMAND                          ; Yes, process it here
2098      P:000666 P:000666 0E9667            JLT     <HACK_FO_XMT                      ; Send it to fiber optic transmitter
2099                                 HACK_FO_XMT
2100      P:000667 P:000667 330700            MOVE              #COM_BUF,R3
2101      P:000668 P:000668 060600            DO      X:<NWORDS,HACK_DON_FFO            ; Transmit all the words in the command
                            00066C
2102      P:00066A P:00066A 57DB00            MOVE              X:(R3)+,B
2103      P:00066B P:00066B 0D00EB            JSR     <XMT_WRD
2104      P:00066C P:00066C 000000            NOP
2105                                 HACK_DON_FFO
2106      P:00066D P:00066D 00000C            RTS
2107   
2108      P:00066E P:00066E 44DB00  EPURGE    MOVE              X:(R3)+,X0              ; Get TIME1 off the command buffer
2109      P:00066F P:00066F 4C1600            MOVE                          X0,Y:<TIME1 ; Move it to the address in tim.asm
2110   
2111                                                                                    ;TODO: Get rid of this horrible hack
2112                                                                                    ;Horrible hack to get over time out on comma
nd return
2113      P:000670 P:000670 0D0653            JSR     <HACK_FINISH
2114      P:000671 P:000671 012F23            BSET    #3,X:PCRD                         ; Turn on the serial clock - this should alr
eady be the case
2115      P:000672 P:000672 0A0F01            BCLR    #1,X:<LATCH                       ; Separate updates of clock driver
2116      P:000673 P:000673 0A0F20            BSET    #CDAC,X:<LATCH                    ; Disable clearing of DACs
2117      P:000674 P:000674 0A0F22            BSET    #ENCK,X:<LATCH                    ; Enable clock and DAC output switches
2118      P:000675 P:000675 09F0B5            MOVEP             X:LATCH,Y:WRLATCH       ; Write it to the hardware
                            00000F
2119      P:000677 P:000677 0D0416            JSR     <PAL_DLY                          ; Delay for all this to happen
2120   
2121                                ; Read DAC values from a table, and write them to the DACs
2122      P:000678 P:000678 60F400            MOVE              #EPUR,R0                ; Get starting address of erase clock values
                            000176
2123      P:00067A P:00067A 000000            NOP
2124      P:00067B P:00067B 000000            NOP
2125      P:00067C P:00067C 065840            DO      Y:(R0)+,E_DAC2                    ; Repeat Y:(R0)+ times
                            000680
2126      P:00067E P:00067E 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2127      P:00067F P:00067F 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2128      P:000680 P:000680 000000            NOP
2129                                E_DAC2
2130   
2131                                ; Let the DAC voltages all ramp before exiting
2132      P:000681 P:000681 44F400            MOVE              #400000,X0
                            061A80
2133      P:000683 P:000683 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000685
2134      P:000685 P:000685 000000            NOP
2135   
2136                                ; Start the delay loop
2137   
2138      P:000686 P:000686 061640            DO      Y:<TIME1,EPUR_T1                  ; Delay TIME1 msec
                            000689
2139      P:000688 P:000688 0D064D            JSR     <LNG_DLY
2140      P:000689 P:000689 000000            NOP
2141   
2142      P:00068A P:00068A 60F400  EPUR_T1   MOVE              #ERHI_END,R0            ; Get the original clock values back.
                            000159
2143      P:00068C P:00068C 000000            NOP
2144      P:00068D P:00068D 000000            NOP
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  timCCDmisc.asm  Page 41



2145      P:00068E P:00068E 065840            DO      Y:(R0)+,END_DAC_RESTORE2          ; Repeat Y:(R0)+ times
                            000692
2146      P:000690 P:000690 5ED800            MOVE                          Y:(R0)+,A   ; Read the table entry
2147      P:000691 P:000691 0D020C            JSR     <XMIT_A_WORD                      ; Transmit it to TIM-A-STD
2148      P:000692 P:000692 000000            NOP
2149                                END_DAC_RESTORE2
2150   
2151                                ; Let the DAC voltages all ramp up before exiting
2152      P:000693 P:000693 44F400            MOVE              #400000,X0
                            061A80
2153      P:000695 P:000695 06C400            DO      X0,*+3                            ; 4 millisec delay
                            000697
2154      P:000697 P:000697 000000            NOP
2155      P:000698 P:000698 0C0054            JMP     <START
2156   
2157   
2158   
2159   
2160   
2161                                 TIMBOOT_X_MEMORY
2162      000699                              EQU     @LCV(L)
2163   
2164                                ;  ****************  Setup memory tables in X: space ********************
2165   
2166                                ; Define the address in P: space where the table of constants begins
2167   
2168                                          IF      @SCP("HOST","HOST")
2169      X:000036 X:000036                   ORG     X:END_COMMAND_TABLE,X:END_COMMAND_TABLE
2170                                          ENDIF
2171   
2172                                          IF      @SCP("HOST","ROM")
2174                                          ENDIF
2175   
2176                                ; Application commands
2177      X:000036 X:000036                   DC      'PON',POWER_ON
2178      X:000038 X:000038                   DC      'POF',POWER_OFF
2179      X:00003A X:00003A                   DC      'SBV',SET_BIAS_VOLTAGES
2180      X:00003C X:00003C                   DC      'IDL',START_IDLE_CLOCKING
2181      X:00003E X:00003E                   DC      'OSH',OPEN_SHUTTER
2182      X:000040 X:000040                   DC      'CSH',CLOSE_SHUTTER
2183      X:000042 X:000042                   DC      'RDC',RDCCD                       ; Begin CCD readout
2184      X:000044 X:000044                   DC      'CLR',CLEAR                       ; Fast clear the CCD
2185   
2186                                ; Exposure and readout control routines
2187      X:000046 X:000046                   DC      'SET',SET_EXPOSURE_TIME
2188      X:000048 X:000048                   DC      'RET',READ_EXPOSURE_TIME
2189      X:00004A X:00004A                   DC      'SEX',START_EXPOSURE
2190      X:00004C X:00004C                   DC      'PEX',PAUSE_EXPOSURE
2191      X:00004E X:00004E                   DC      'REX',RESUME_EXPOSURE
2192      X:000050 X:000050                   DC      'AEX',ABORT_EXPOSURE
2193      X:000052 X:000052                   DC      'ABR',ABR_RDC
2194      X:000054 X:000054                   DC      'CRD',CONTINUE_READ
2195      X:000056 X:000056                   DC      'WSI',SYNTHETIC_IMAGE
2196   
2197                                ; Support routines
2198      X:000058 X:000058                   DC      'SGN',ST_GAIN
2199      X:00005A X:00005A                   DC      'SBN',SET_BIAS_NUMBER
2200      X:00005C X:00005C                   DC      'SMX',SET_MUX
2201      X:00005E X:00005E                   DC      'CSW',CLR_SWS
2202      X:000060 X:000060                   DC      'SOS',SELECT_OUTPUT_SOURCE
2203      X:000062 X:000062                   DC      'SSS',SET_SUBARRAY_SIZES
2204      X:000064 X:000064                   DC      'SSP',SET_SUBARRAY_POSITIONS
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 42



2205      X:000066 X:000066                   DC      'RCC',READ_CONTROLLER_CONFIGURATION
2206      X:000068 X:000068                   DC      'RAW',RAW_COMMAND                 ; So I can set voltages as I please
2207      X:00006A X:00006A                   DC      'ERS',ERASE                       ;Persistent image erase
2208      X:00006C X:00006C                   DC      'EPG',EPURGE                      ; E-Purge procedure
2209   
2210                                 END_APPLICATION_COMMAND_TABLE
2211      00006E                              EQU     @LCV(L)
2212   
2213                                          IF      @SCP("HOST","HOST")
2214      000023                    NUM_COM   EQU     (@LCV(R)-COM_TBL_R)/2             ; Number of boot +
2215                                                                                    ;  application commands
2216      00037C                    EXPOSING  EQU     CHK_TIM                           ; Address if exposing
2217                                 CONTINUE_READING
2218      100000                              EQU     CONT_RD                           ; Address if reading out
2219                                          ENDIF
2220   
2221                                          IF      @SCP("HOST","ROM")
2223                                          ENDIF
2224   
2225                                ; Now let's go for the timing waveform tables
2226                                          IF      @SCP("HOST","HOST")
2227      Y:000000 Y:000000                   ORG     Y:0,Y:0
2228                                          ENDIF
2229   
2230      Y:000000 Y:000000         GAIN      DC      END_APPLICATON_Y_MEMORY-@LCV(L)-1
2231   
2232      Y:000001 Y:000001         NSR       DC      4200                              ; Number Serial Read, prescan + image + bias
2233      Y:000002 Y:000002         NPR       DC      2100                              ; Number Parallel Read
2234      Y:000003 Y:000003         NSCLR     DC      NS_CLR                            ; To clear the serial register
2235      Y:000004 Y:000004         NPCLR     DC      NP_CLR                            ; To clear the parallel register
2236      Y:000005 Y:000005         NSBIN     DC      1                                 ; Serial binning parameter
2237      Y:000006 Y:000006         NPBIN     DC      1                                 ; Parallel binning parameter
2238      Y:000007 Y:000007         TST_DAT   DC      0                                 ; Temporary definition for test images
2239      Y:000008 Y:000008         SHDEL     DC      SH_DEL                            ; Delay in milliseconds between shutter clos
ing
2240                                                                                    ; and image readout
2241      Y:000009 Y:000009         CONFIG    DC      CC                                ; Controller configuration
2242                                 NSERIALS_READ
2243      Y:00000A Y:00000A                   DC      4200                              ; Number of serials to read
2244   
2245                                ; Waveform parameters
2246      Y:00000B Y:00000B         OS        DC      '_U1'                             ; Output source
2247                                 FIRST_CLOCKS
2248      Y:00000C Y:00000C                   DC      0                                 ; Address of first clocks waveforms
2249      Y:00000D Y:00000D         CLOCK_LINE DC     0                                 ; Clock one complete line of charge
2250   
2251                                ; Readout peculiarity parameters. Default values are selected here.
2252                                 SERIAL_READ
2253      Y:00000E Y:00000E                   DC      SERIAL_READ_RIGHT                 ;14  ; Serial readout waveforms
2254                                 SERIAL_SKIP
2255      Y:00000F Y:00000F                   DC      SERIAL_SKIP_RIGHT                 ;15  ; Serial skipping waveforms
2256      Y:000010 Y:000010         PARALLEL  DC      PARALLEL_1                        ;16  ; Parallel shifting waveforms
2257                                 PARALLEL_CLEAR
2258      Y:000011 Y:000011                   DC      PARALLEL_CLEAR_1                  ;17
2259                                 SERIAL_IDLE
2260      Y:000012 Y:000012                   DC      SERIAL_IDLE_LEFT                  ;20
2261                                 N_PARALLEL_CLEARS
2262      Y:000013 Y:000013                   DC      1                                 ;29
2263      Y:000014 Y:000014         NSRI      DC      4200
2264   
2265   
2266      Y:000015 Y:000015         INT_TIME  DC      0
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  tim.asm  Page 43



2267      Y:000016 Y:000016         TIME1     DC      0
2268      Y:000017 Y:000017         TIME2     DC      0
2269   
2270                                ; These three parameters are read from the READ_TABLE when needed by the
2271                                ;   RDCCD routine as it loops through the required number of boxes
2272      Y:000018 Y:000018         NP_SKIP   DC      0                                 ; Number of rows to skip
2273      Y:000019 Y:000019         NS_SKP1   DC      0                                 ; Number of serials to clear before read
2274      Y:00001A Y:00001A         NS_SKP2   DC      0                                 ; Number of serials to clear after read
2275   
2276                                ; Subimage readout parameters. Ten subimage boxes maximum.
2277      Y:00001B Y:00001B         NBOXES    DC      0                                 ; Number of boxes to read
2278      Y:00001C Y:00001C         NR_BIAS   DC      0                                 ; Number of bias pixels to read
2279      Y:00001D Y:00001D         NS_READ   DC      0                                 ; Number of columns in subimage read
2280      Y:00001E Y:00001E         NP_READ   DC      0                                 ; Number of rows in subimage read
2281      Y:00001F Y:00001F         READ_TABLE DC     0,0,0                             ; #1 = Number of rows to clear
2282                                                                                    ; #2 = Number of columns to skip before
2283                                                                                    ;   subimage read
2284                                                                                    ; #3 = Number of rows to clear after
2285                                                                                    ;   subimage clear
2286   
2287                                ; Include the waveform table for the designated type of CCD
2288                                          INCLUDE "sg2.waveforms.reverse"           ; Readout and clocking waveform file
2289                                ; vim: syntax=asm
2290   
2291                                ; Waveform tables and definitions for the LBNL CCD
2292                                ; This is for a slow, low noise readout
2293                                ; In this version the reset encloses the three serial clocks
2294                                ;**********************************************************************
2295   
2296                                ; U2 and L2 working.
2297                                ; Parallel clocking also needs fixing as shifting to register 1 has
2298                                ; charge under different phases during integration and clocking
2299   
2300                                ; Miscellaneous definitions
2301   
2302      000000                    VIDEO     EQU     $000000                           ; Video processor board select
2303      000000                    VID0      EQU     $000000                           ; Video processor board select
2304      002000                    BIAS      EQU     $002000                           ; Bias Generator board select = 3
2305      003000                    HVBIAS    EQU     $003000                           ; Bias Generator board select = 3
2306      002000                    CLK2      EQU     $002000                           ; Clock driver board select = 2
2307      003000                    CLK3      EQU     $003000                           ; Clock driver board select = 3
2308                                ;CLK4      EQU $004000 ; Clock driver board select = 4
2309                                ;CLK5      EQU $005000 ; Clock driver board select = 5
2310   
2311                                 VIDEO_CONFIG
2312      0C000C                              EQU     $0C000C                           ; WARP = DAC_OUT = ON; H16B, Reset FIFOs
2313      0E0000                    DAC_ADDR  EQU     $0E0000                           ; DAC Channel Address
2314      0F4000                    DAC_RegM  EQU     $0F4000                           ; DAC m Register
2315      0F8000                    DAC_RegC  EQU     $0F8000                           ; DAC c Register
2316      0FC000                    DAC_RegD  EQU     $0FC000                           ; DAC X1 Register
2317   
2318      -5.000000E+000            VABG      EQU     -5.0                              ; Anti-blooming gate
2319      8.700000E+000             VRSV_MAX  EQU     8.70
2320      000D9A                    DAC_VRSV  EQU     @CVI(((VABG+VRSV_MAX)/VRSV_MAX)*8192-1) ; Bipolar
2321   
2322      000834                    NP_CLR    EQU     2100
2323      001068                    NS_CLR    EQU     4200
2324   
2325                                ; GenIII: if bit #23=1; 22-16 = # of 640 nanos cycles that bits #15-0 held at
2326                                ;         if bit #23=0; 22-16 = # of  40 nanos cycles that bits #15-0 held at
2327   
2328   
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 44



2329   
2330                                ;I_DELAY  EQU $990000 ; Integration period 25*160+80 = 4080 ns
2331   
2332                                ;I_DELAY         EQU     $880000
2333                                ;I_DELAY         EQU     $880000
2334                                ;I_DELAY         EQU     $180000
2335                                ;I_DELAY         EQU     $7D0000
2336                                ;I_DELAY         EQU     $AD0000
2337                                ;I_DELAY         EQU     $AD0000
2338                                ;I_DELAY         EQU     $FD0000
2339                                ;I_DELAY         EQU     $60000
2340      380000                    I_DELAY   EQU     $380000
2341   
2342                                ;I_DELAY         EQU     $180000
2343                                ;I_DELAY         EQU     $300000 ; 2x$180000
2344                                ;I_DELAY         EQU     $2a0000
2345   
2346   
2347                                ; Delay numbers for clocking
2348      9E0000                    P_DELAY   EQU     $9E0000
2349   
2350                                ;30 KHz waveforms
2351      210000                    S_DELAY   EQU     $210000                           ; Serial register transfer delay
2352      210000                    SW_DELAY  EQU     $210000                           ; Sum_well  clock delay = 96*20+80 = 2000 ns
2353                                 PRE_SET_DLY
2354      210000                              EQU     $210000                           ;1360ns delay from GenIICode
2355                                 POST_SET_DLY
2356      210000                              EQU     $210000                           ;1360ns delay from GenIICode
2358                                 DCRST_DELAY
2359      210000                              EQU     $210000                           ;1360ns delay from GenIICode
2371                                ;PRE_SET_DLY     EQU     $180000 ;1000ns delay from GenIICode
2372                                ;POST_SET_DLY    EQU     $180000 ;1000ns delay from GenIICode
2373                                ;DCRST_DELAY     EQU     $180000 ;1000ns delay from GenIICode
2374   
2375                                ;PRE_SET_DLY     EQU     $000000
2376                                ;POST_SET_DLY    EQU     $000000
2377                                ;DCRST_DELAY     EQU     $000000
2378   
2379                                ;98 KHz clocking waveforms
2380                                ;S_DELAY         EQU     $70000
2381                                ;SW_DELAY        EQU     $c0000
2382                                ;PRE_SET_DLY     EQU     $70000
2383                                ;POST_SET_DLY    EQU     $70000
2385                                ;DCRST_DELAY     EQU     $70000
2387   
2388                                ; some faster waveforms than 30KHz
2389   
2390                                ;S_DELAY         EQU     $180000
2391                                ;SW_DELAY        EQU     $180000
2392                                ;PRE_SET_DLY     EQU     $300000
2393                                ;POST_SET_DLY    EQU     $240000
2394                                ;DCRST_DELAY     EQU     $70000
2395   
2396                                ; TODO: Is this a waste of clearing in split readout mode?  Calculate.
2397                                ;NP_CLR  EQU     2048  ; 2040 parallel direction
2398                                ;This doesn't do anything
2399                                ;NP_CLR  EQU     2100  ; 2040 parallel direction
2400                                ;NS_CLR  EQU     4200    ; 4128 in serial direction
2401                                ;NS_CLR  EQU     4128    ; 4128 in serial direction
2402      000032                    SH_DEL    EQU     50
2403   
2404                                ; CHANGE ABOVE TO GENIII TIMING BOARD DELAYS
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 45



2405   
2406                                ; Macros to help getting from volts to bits.
2407                                ; The \ in front of NAME substitutes the value of NAME into the variable. (tx)
2408   
2409                                VDEF      MACRO   NAME,BRDTYP,BRDNUM,DAC,ALO,AHI
2410 m 
2411 m                              LO_\NAME  EQU     ALO
2412 m                              HI_\NAME  EQU     AHI
2413 m                              DAC_\NAME EQU     DAC
2414 m                               BRDNUM_\NAME
2415 m                                        EQU     BRDNUM
2416 m                                        IF      @SCP("BRDTYP",'VID')
2417 m                               BRDTYP_\NAME
2418 m                                        EQU     3
2419 m                                        ELSE
2420 m                               BRDTYP_\NAME
2421 m                                        EQU     0
2422 m                                        ENDIF
2423 m 
2424 m                              ;        MSG     'Defining voltage ',"NAME",' type ',"BRDTYP",' board ',"BRDNUM",' dac ',"DAC",'
 with limits ',"ALO",' ',"AHI"
2425 m                                        ENDM
2426   
2427                                VOLTS     MACRO   NAME,F
2428 m 
2429 m                              DUMMY     SET     @CVI(@MIN(4095,@MAX(0,(F-LO_\NAME)/(HI_\NAME-LO_\NAME)*4096.)))
2430 m                              DUMMY2    SET     @CVI((BRDNUM_\NAME<<20)|(BRDTYP_\NAME<<18)|(DAC_\NAME<<14)|DUMMY)
2431 m                                        DC      DUMMY2
2432 m                                        MSG     'Setting voltage ',"NAME ","F",'V ',DUMMY,DUMMY2
2433 m                                        ENDM
2434   
2435                                ;*********************************************************************
2436                                ;
2437                                ; ; define bias board voltage symbols
2438                                          VDEF    VDDL2,VID,2,0,0.0,-25.0
2451                                          VDEF    VDDU2,VID,2,1,0.0,-25.0
2464                                          VDEF    VDDL1,VID,2,2,0.0,-25.0
2477                                          VDEF    VDDU1,VID,2,3,0.0,-25.0
2490                                          VDEF    VRL2,VID,2,4,0.0,-25.0
2503                                          VDEF    VRU2,VID,2,5,0.0,-25.0
2516                                          VDEF    VRL1,VID,2,6,0.0,-25.0
2529                                          VDEF    VRU1,VID,2,7,0.0,-25.0
2542                                          VDEF    VOGL2,VID,2,8,0.0,5
2555                                          VDEF    VOGU2,VID,2,9,0.0,5
2568                                          VDEF    VOGL1,VID,2,10,0.0,5
2581                                          VDEF    VOGU1,VID,2,11,0.0,5
2594                                          VDEF    VSUB,VID,2,12,0.0,80.0
2607                                          VDEF    RAMP,VID,2,13,0.0,10.0            ;  for ramping p.s.
2620                                ;
2621                                ; ; define clock board symbols bank0
2622                                ;
2623   
2624   
2625                                ; Output video offset parameters
2626      001F00                    OFFSET0   EQU     $1F00
2627      001F00                    OFFSET1   EQU     $1F00
2628      002000                    OFFSET2   EQU     $2000
2629      001F00                    OFFSET3   EQU     $1F00
2630   
2631                                ; CCD clock voltage
2632      0.000000E+000             ZERO      EQU     0.0                               ; Unused pins
2633      1.300000E+001             Vmax      EQU     +13.0                             ; Clock driver board rails
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 46



2634   
2635                                ;LBNL DEFINITIONS
2636      5.000000E+000             V1_HI     EQU     5.0                               ; Vertical High
2637      -3.000000E+000            V1_LO     EQU     -3.0                              ; Vertical Low
2638      5.000000E+000             V2_HI     EQU     5.0                               ; Vertical High
2639      -3.000000E+000            V2_LO     EQU     -3.0                              ; Vertical Low
2640      5.000000E+000             V3_HI     EQU     5.0                               ; Vertical High
2641      -3.000000E+000            V3_LO     EQU     -3.0                              ; Vertical Low
2642   
2643      5.000000E+000             FS1_HI    EQU     5.0                               ; Vertical High
2644      -3.000000E+000            FS1_LO    EQU     -3.0                              ; Vertical Low
2645      5.000000E+000             FS2_HI    EQU     5.0                               ; Vertical High
2646      -3.000000E+000            FS2_LO    EQU     -3.0                              ; Vertical Low
2647      5.000000E+000             FS3_HI    EQU     5.0                               ; Vertical High
2648      -3.000000E+000            FS3_LO    EQU     -3.0                              ; Vertical Low
2649   
2650      5.000000E+000             T2_HI     EQU     5.0                               ; Transfer gate High
2651      -3.000000E+000            T2_LO     EQU     -3.0                              ; Transfer gate Low
2652      5.000000E+000             T1_HI     EQU     5.0                               ; Transfer gate High
2653      -3.000000E+000            T1_LO     EQU     -3.0                              ; Transfer gate Low
2654   
2655      6.000000E+000             H1U1_L2_HI EQU    +6.0                              ; Horizontal High
2656      -3.900000E+000            H1U1_L2_LO EQU    -3.9                              ; Horizontal Low
2657      6.000000E+000             H2U1_L2_HI EQU    +6.0                              ; Horizontal High
2658      -3.900000E+000            H2U1_L2_LO EQU    -3.9                              ; Horizontal Low
2659      6.000000E+000             H3U1_L2_HI EQU    +6.0                              ; Horizontal High
2660      -3.900000E+000            H3U1_L2_LO EQU    -3.9                              ; Horizontal Low
2661      6.000000E+000             H1U2_L1_HI EQU    +6.0                              ; Horizontal High
2662      -3.900000E+000            H1U2_L1_LO EQU    -3.9                              ; Horizontal Low
2663      6.000000E+000             H2U2_L1_HI EQU    +6.0                              ; Horizontal High
2664      -3.900000E+000            H2U2_L1_LO EQU    -3.9                              ; Horizontal Low
2665      6.000000E+000             H3U2_L1_HI EQU    +6.0                              ; Horizontal High
2666      -3.900000E+000            H3U2_L1_LO EQU    -3.9                              ; Horizontal Low
2667   
2668                                ;H1U1_L2_HI  EQU +0.0 ; Horizontal High
2669                                ;H1U1_L2_LO  EQU -0.0 ; Horizontal Low
2670                                ;H2U1_L2_HI  EQU +0.0 ; HoVR2rizontal High
2671                                ;H2U1_L2_LO  EQU -0.0 ; Horizontal Low
2672                                ;H3U1_L2_HI  EQU +0.0 ; Horizontal High
2673                                ;H3U1_L2_LO  EQU -0.0 ; Horizontal Low
2674                                ;H1U2_L1_HI  EQU +0.0 ; Horizontal High
2675                                ;H1U2_L1_LO  EQU -0.0 ; Horizontal Low
2676                                ;H2U2_L1_HI  EQU +0.0 ; Horizontal High
2677                                ;H2U2_L1_LO  EQU -0.0 ; Horizontal Low
2678                                ;H3U2_L1_HI  EQU +0.0 ; Horizontal High
2679                                ;H3U2_L1_LO  EQU -0.0 ; Horizontal Low
2680                                ;
2681                                ;Put summing wells low for conduction channel
2682      5.000000E+000             SWU_HI    EQU     +5.0                              ; Summing Well High
2683      -5.000000E+000            SWU_LO    EQU     -5.0                              ; Summing Well Low
2684      5.000000E+000             SWL_HI    EQU     +5.0                              ; Summing Well High
2685      -5.000000E+000            SWL_LO    EQU     -5.0                              ; Summing Well Low
2686   
2687      -6.000000E+000            RU_HI     EQU     -6.0                              ; Reset ACTIVE wrong polarity....
2688      -1.000000E-001            RU_LO     EQU     -0.1                              ; Reset INACTIVE
2689      -6.000000E+000            RL_HI     EQU     -6.0                              ; Reset ACTIVE wrong polarity....
2690      -1.000000E-001            RL_LO     EQU     -0.1                              ; Reset INACTIVE
2691   
2692   
2693                                ; Bit defintions for bottom half of clock driver board, CLK2
2694                                ; Clock FS ando vertical regions together
2695                                ; 1,2,4,8,10,20,40,80,100,200,400,800
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 47



2696   
2697      000009                    V1_1H     EQU     1|8                               ; V1: Pin 1 -- FS1: pin 4
2698      000000                    V1_1L     EQU     0
2699   
2700      000012                    V2_1H     EQU     2|$10                             ; V2: Pin 2 -- FS2: pin 5
2701      000000                    V2_1L     EQU     0
2702   
2703      000024                    V3_1H     EQU     4|$20                             ; V3: pin 3 -- FS3: pin 6
2704      000000                    V3_1L     EQU     0
2705   
2706      000240                    V1_2H     EQU     $40|$200                          ; V1: pin 7 -- FS1: pin 10
2707      000000                    V1_2L     EQU     0
2708   
2709      000480                    V2_2H     EQU     $80|$400                          ; V2: pin 8 -- FS2: pin 11
2710      000000                    V2_2L     EQU     0
2711   
2712      000900                    V3_2H     EQU     $100|$800                         ; V3: pin 9 -- FS3: pin 12
2713      000000                    V3_2L     EQU     0
2714   
2715   
2716                                ; Top bank
2717   
2718      000001                    H1_1H     EQU     1                                 ; Horizontal 1 Upper Pin 13
2719      000000                    H1_1L     EQU     0
2720   
2721      000002                    H1_2H     EQU     2                                 ; Horizontal 2 Upper, Pin 14
2722      000000                    H1_2L     EQU     0
2723   
2724      000004                    H1_3H     EQU     4                                 ; Horizontal 3 Upper, Pin 15
2725      000000                    H1_3L     EQU     0
2726   
2727      000008                    H2_1H     EQU     8                                 ; Horizontal 1 Lower, Pin 16
2728      000000                    H2_1L     EQU     0
2729   
2730      000010                    H2_2H     EQU     $10                               ; Horizontal 2 Lower, Pin 17
2731      000000                    H2_2L     EQU     0
2732   
2733      000020                    H2_3H     EQU     $20                               ; Horizontal 3 Lower, Pin 18
2734      000000                    H2_3L     EQU     0
2735   
2736      000040                    SWUH      EQU     $40                               ; Summing Well Upper, Pin 19
2737      000000                    SWUL      EQU     0
2738   
2739      000080                    SWLH      EQU     $80                               ; Summing Well Lower, Pin 33
2740      000000                    SWLL      EQU     0
2741   
2742      000100                    RLH       EQU     $100                              ; Reset Gate Upper, Pin 34
2743      000000                    RLL       EQU     0
2744   
2745      000200                    RUH       EQU     $200                              ; Reset Gate Lower, Pin 35
2746      000000                    RUL       EQU     0
2747   
2748      000400                    T1        EQU     $400                              ; Transfer Gate Upper, Pin 36
2749      000800                    T2        EQU     $800                              ; Transfer Gate Lower, Pin 37
2750   
2751                                ;Both summing wells;
2752                                ;SWUH+SWLH = $80+$100
2753                                ;This was wrong -- should be $40+$80.
2754      000000                    WL        EQU     0
2755      0000C0                    WH        EQU     $c0
2756   
2757      000000                    RL        EQU     0
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 48



2758      000300                    RH        EQU     $300
2759   
2760                                ;both transfer gates together
2761      000000                    TL        EQU     0
2762      000C00                    TH        EQU     $c00
2763   
2764                                ; LBNL waveforms
2765   
2766                                ;TODO:  Need to remove references to frame store clocks -- I've bussed
2767                                ;       those together with the verticals in the 1&2 halves.  Fortunately
2768                                ;       the switch state bits select the right thing at the moment...
2769                                ;TODO:  Check first CLK3 line for parallel split is correct.
2770   
2771   
2772                                 PARALLEL_SPLIT
2773      Y:000022 Y:000022                   DC      END_PARALLEL_SPLIT-PARALLEL_SPLIT-1
2774      Y:000023 Y:000023                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2775      Y:000024 Y:000024                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2776      Y:000025 Y:000025                   DC      CLK2|P_DELAY|V1_1L|V2_1L|V3_1H|V1_2H|V2_2L|V3_2L
2777      Y:000026 Y:000026                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2H|V2_2H|V3_2L
2778      Y:000027 Y:000027                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2779      Y:000028 Y:000028                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2L|V2_2H|V3_2H
2780      Y:000029 Y:000029                   DC      CLK2|$000000|V1_1H|V2_1L|V3_1L|V1_2L|V2_2L|V3_2H
2781      Y:00002A Y:00002A                   DC      CLK3|P_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Shut the transfer g
ate
2782   
2783   
2784                                END_PARALLEL_SPLIT
2785   
2786   
2787                                ;Shift towards register 2
2788      Y:00002B Y:00002B         PARALLEL_2 DC     END_PARALLEL_2-PARALLEL_2-1
2789      Y:00002C Y:00002C                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2790      Y:00002D Y:00002D                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2791      Y:00002E Y:00002E                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1L|V1_2H|V2_2L|V3_2L
2792      Y:00002F Y:00002F                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2H|V2_2H|V3_2L
2793      Y:000030 Y:000030                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2794      Y:000031 Y:000031                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2L|V2_2H|V3_2H
2795      Y:000032 Y:000032                   DC      CLK2|$000000|V1_1L|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H ; shut TG
2796      Y:000033 Y:000033                   DC      CLK3|P_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Shut the transfer g
ate
2797                                END_PARALLEL_2
2798   
2799                                ;Shift towards register 1
2800                                ;charge stored under 2&3.  Issue with switching between which register to go to.
2801      Y:000034 Y:000034         PARALLEL_1 DC     END_PARALLEL_1-PARALLEL_1-1
2802      Y:000035 Y:000035                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2803      Y:000036 Y:000036                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2804      Y:000037 Y:000037                   DC      CLK2|P_DELAY|V1_1L|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H
2805      Y:000038 Y:000038                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2L|V2_2H|V3_2H
2806      Y:000039 Y:000039                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2807      Y:00003A Y:00003A                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2H|V2_2H|V3_2L
2808      Y:00003B Y:00003B                   DC      CLK2|$000000|V1_1H|V2_1L|V3_1L|V1_2H|V2_2L|V3_2L
2809      Y:00003C Y:00003C                   DC      CLK3|P_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Shut the transfer g
ate
2810      Y:00003D Y:00003D                   DC      VIDEO+$000000+%1111000            ; ADCLatch,NonInv,DCRestore,StrtRstInt. - wf
k add DCRestore,StrtRstInt
2811                                END_PARALLEL_1
2812   
2813   
2814                                PARALLEL_CLEAR_1
2815      Y:00003E Y:00003E                   DC      END_PARALLEL_CLEAR_1-PARALLEL_CLEAR_1-1
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 49



2816      Y:00003F Y:00003F                   DC      CLK3|$000000|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2817   
2818      Y:000040 Y:000040                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2819      Y:000041 Y:000041                   DC      CLK2|P_DELAY|V1_1L|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H
2820      Y:000042 Y:000042                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2L|V2_2H|V3_2H
2821      Y:000043 Y:000043                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2822      Y:000044 Y:000044                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2H|V2_2H|V3_2L
2823      Y:000045 Y:000045                   DC      CLK2|$000000|V1_1H|V2_1L|V3_1L|V1_2H|V2_2L|V3_2L
2824   
2825      Y:000046 Y:000046                   DC      CLK3|P_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Shut the transfer g
ate
2826                                                                                    ; wfk -  Next line: Add DCRestore,StrtRstInt
 to machine state at end of CLEAR to stabilize baseline (04/04/07)
2827      Y:000047 Y:000047                   DC      VIDEO+$000000+%1111000            ; ADCLatch,NonInv,DCRestore,StrtRstInt. - wf
k add DCRestore,StrtRstInt
2828                                END_PARALLEL_CLEAR_1
2829   
2830                                PARALLEL_CLEAR_2
2831      Y:000048 Y:000048                   DC      END_PARALLEL_CLEAR_2-PARALLEL_CLEAR_2-1
2832      Y:000049 Y:000049                   DC      CLK3|$000000|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2833   
2834      Y:00004A Y:00004A                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2835      Y:00004B Y:00004B                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1L|V1_2H|V2_2L|V3_2L
2836      Y:00004C Y:00004C                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2H|V2_2H|V3_2L
2837      Y:00004D Y:00004D                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2838      Y:00004E Y:00004E                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2L|V2_2H|V3_2H
2839      Y:00004F Y:00004F                   DC      CLK2|$000000|V1_1L|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H
2840      Y:000050 Y:000050                   DC      CLK3|P_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Shut the transfer g
ate
2841   
2842   
2843                                                                                    ; wfk -  Next line: Add DCRestore,StrtRstInt
 to machine state at end of CLEAR to stabilize baseline (04/04/07)
2844      Y:000051 Y:000051                   DC      VIDEO+$000000+%1111000            ; ADCLatch,NonInv,DCRestore,StrtRstInt. - wf
k add DCRestore,StrtRstInt
2845                                END_PARALLEL_CLEAR_2
2846   
2847                                ; this parallel split mixes two central rows on the CCD.
2848                                PARALLEL_CLEAR_SPLIT
2849      Y:000052 Y:000052                   DC      END_PARALLEL_CLEAR_SPLIT-PARALLEL_CLEAR_SPLIT-1
2850      Y:000053 Y:000053                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2851   
2852      Y:000054 Y:000054                   DC      CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2853      Y:000055 Y:000055                   DC      CLK2|P_DELAY|V1_1L|V2_1L|V3_1H|V1_2H|V2_2L|V3_2L
2854      Y:000056 Y:000056                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2H|V2_2H|V3_2L
2855      Y:000057 Y:000057                   DC      CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2856      Y:000058 Y:000058                   DC      CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2L|V2_2H|V3_2H
2857      Y:000059 Y:000059                   DC      CLK2|$000000|V1_1H|V2_1L|V3_1L|V1_2L|V2_2L|V3_2H
2858   
2859      Y:00005A Y:00005A                   DC      CLK3|P_DELAY|RL|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH
2860                                                                                    ; wfk -  Next line: Add DCRestore,StrtRstInt
 to machine state at end of CLEAR to stabilize baseline (04/04/07)
2861      Y:00005B Y:00005B                   DC      VIDEO+$000000+%1111000            ; ADCLatch,NonInv,DCRestore,StrtRstInt. - wf
k add DCRestore,StrtRstInt
2862                                END_PARALLEL_CLEAR_SPLIT
2863   
2864   
2865   
2867                                ;PARALLEL_CLEAR_SPLIT
2868                                ;  DC  END_PARALLEL_CLEAR_SPLIT-PARALLEL_CLEAR_SPLIT-1
2869                                ;  DC  CLK3|$000000|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TL ;SW->lo
2870                                ;
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 50



2871                                ;  DC  CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2H|V2_2L|V3_2H
2872                                ;  DC  CLK2|P_DELAY|V1_1L|V2_1L|V3_1H|V1_2H|V2_2L|V3_2L
2873                                ;  DC  CLK2|P_DELAY|V1_1L|V2_1H|V3_1H|V1_2H|V2_2H|V3_2L
2874                                ;  DC  CLK2|P_DELAY|V1_1L|V2_1H|V3_1L|V1_2L|V2_2H|V3_2L
2875                                ;  DC  CLK2|P_DELAY|V1_1H|V2_1H|V3_1L|V1_2L|V2_2H|V3_2H
2876                                ;  DC  CLK2|P_DELAY|V1_1H|V2_1L|V3_1L|V1_2L|V2_2L|V3_2H
2877                                ;  DC  CLK2|P_DELAY|V1_1H|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H
2878                                ;  DC  CLK2|$000000|V1_1L|V2_1L|V3_1H|V1_2L|V2_2L|V3_2H
2879                                ;
2880                                ;  DC  CLK3|P_DELAY|RL|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH
2881                                ;  ; wfk -  Next line: Add DCRestore,StrtRstInt to machine state at end of CLEAR to stabilize ba
seline (04/04/07)
2882                                ;  DC  VIDEO+$000000+%1111000  ; ADCLatch,NonInv,DCRestore,StrtRstInt. - wfk add DCRestore,StrtR
stInt
2883                                ;END_PARALLEL_CLEAR_SPLIT
2884   
2885                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
2886                                SERIAL_IDLE_LEFT                                    ; Clock serial charge from both L and R ends
2887      Y:00005C Y:00005C                   DC      END_SERIAL_IDLE_LEFT-SERIAL_IDLE_LEFT-1
2888      Y:00005D Y:00005D                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
2889   
2890                                ; L2 idle version
2891                                ; 2->3->1->2->3
2892      Y:00005E Y:00005E                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
2893      Y:00005F Y:00005F                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
2894      Y:000060 Y:000060                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
2895      Y:000061 Y:000061                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
2896      Y:000062 Y:000062                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
2897      Y:000063 Y:000063                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
2898      Y:000064 Y:000064                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
2899   
2900   
2901      Y:000065 Y:000065                   DC      CLK3|$0000000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for trans
mit delay
2902      Y:000066 Y:000066                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
2903      Y:000067 Y:000067                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
2904      Y:000068 Y:000068                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
2905      Y:000069 Y:000069                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi -- charge d
ump
2906   
2907                                                                                    ;SW going low here suggests that no charge w
ill leak over OG barrier onto sense node.
2908      Y:00006A Y:00006A                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
2909      Y:00006B Y:00006B                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
2910      Y:00006C Y:00006C                   DC      VIDEO+$000000+%0010001            ; StopIntegrator
2911      Y:00006D Y:00006D                   DC      VIDEO+DCRST_DELAY+%0110001        ; ,NonInv  ;mF to do ADC sampling before res
etting
2912   
2913   
2914   
2915                                ;  DC  CLK3|POST_SET_DLY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL ;SW->lo
2916   
2917                                END_SERIAL_IDLE_LEFT
2918   
2919   
2920                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
2921                                SERIAL_IDLE_LEFT_NO_POL                             ; Clock serial charge from both L and R ends
2922      Y:00006E Y:00006E                   DC      END_SERIAL_IDLE_LEFT_NO_POL-SERIAL_IDLE_LEFT_NO_POL-1
2923      Y:00006F Y:00006F                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
2924   
2925                                ; L2 idle version
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 51



2926                                ; 2->3->1->2->3
2927      Y:000070 Y:000070                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
2928   
2929   
2930                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
2931                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
2932                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
2933                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
2934                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
2935   
2936      Y:000071 Y:000071                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2L|H1_3L|H2_1H|H2_2L|H2_3L|WL|TH ;h2->hi
2937      Y:000072 Y:000072                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2H|H1_3L|H2_1H|H2_2H|H2_3L|WL|TH ;h1->lo
2938      Y:000073 Y:000073                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3L|H2_1L|H2_2H|H2_3L|WL|TH ;h3->hi
2939      Y:000074 Y:000074                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3H|H2_1L|H2_2H|H2_3H|WL|TH ;h2->lo
2940      Y:000075 Y:000075                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2L|H1_3H|H2_1L|H2_2L|H2_3H|WL|TH ;h1->hi
2941   
2942      Y:000076 Y:000076                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
2943   
2944   
2945      Y:000077 Y:000077                   DC      CLK3|$0000000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for trans
mit delay
2946      Y:000078 Y:000078                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
2947      Y:000079 Y:000079                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
2948      Y:00007A Y:00007A                   DC      VIDEO+$000000+%0011001            ; Stop Integrate and sel inverting int.
2949      Y:00007B Y:00007B                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi -- charge d
ump
2950   
2951                                                                                    ;SW going low here suggests that no charge w
ill leak over OG barrier onto sense node.
2952      Y:00007C Y:00007C                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
2953      Y:00007D Y:00007D                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
2954      Y:00007E Y:00007E                   DC      VIDEO+$000000+%0011001            ; StopIntegrator
2955      Y:00007F Y:00007F                   DC      VIDEO+DCRST_DELAY+%0111001        ; ,NonInv  ;mF to do ADC sampling before res
etting
2956   
2957                                ;  DC  CLK3|POST_SET_DLY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL ;SW->lo
2958                                END_SERIAL_IDLE_LEFT_NO_POL
2959   
2960                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
2961                                SERIAL_IDLE_RIGHT                                   ; Clock serial charge from both L and R ends
2962      Y:000080 Y:000080                   DC      END_SERIAL_IDLE_RIGHT-SERIAL_IDLE_RIGHT-1
2963      Y:000081 Y:000081                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
2964   
2965                                ; L2 read version
2966                                ; 2->3->1->2->3
2967      Y:000082 Y:000082                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h2->lo,SW->lo,Reset
_On
2968      Y:000083 Y:000083                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
2969      Y:000084 Y:000084                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->hi
2970      Y:000085 Y:000085                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->l
2971      Y:000086 Y:000086                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->hi
2972      Y:000087 Y:000087                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->lo
2973      Y:000088 Y:000088                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->hi, Reset_O
ff|Delay
2974   
2975   
2976      Y:000089 Y:000089                   DC      CLK3|$0000000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for trans
mit delay
2977      Y:00008A Y:00008A                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
2978      Y:00008B Y:00008B                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
2979      Y:00008C Y:00008C                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 52



2980      Y:00008D Y:00008D                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi -- charge d
ump
2981   
2982                                                                                    ;SW going low here suggests that no charge w
ill leak over OG barrier onto sense node.
2983      Y:00008E Y:00008E                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
2984      Y:00008F Y:00008F                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
2985      Y:000090 Y:000090                   DC      VIDEO+$000000+%0010001            ; StopIntegrator
2986      Y:000091 Y:000091                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampling be
fore resetting
2987   
2988                                ;  DC  CLK3|POST_SET_DLY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL ;SW->lo
2989   
2990                                END_SERIAL_IDLE_RIGHT
2991   
2992   
2993                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
2994                                SERIAL_IDLE_RIGHT_NO_POL                            ; Clock serial charge from both L and R ends
2995      Y:000092 Y:000092                   DC      END_SERIAL_IDLE_RIGHT_NO_POL-SERIAL_IDLE_RIGHT_NO_POL-1
2996      Y:000093 Y:000093                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
2997   
2998                                ; L2 read version
2999                                ; 2->3->1->2->3
3000      Y:000094 Y:000094                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h2->lo,SW->lo,Reset
_On
3001      Y:000095 Y:000095                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3002      Y:000096 Y:000096                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->hi
3003      Y:000097 Y:000097                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->l
3004      Y:000098 Y:000098                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->hi
3005      Y:000099 Y:000099                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->lo
3006      Y:00009A Y:00009A                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->hi, Reset_O
ff|Delay
3007   
3008   
3009      Y:00009B Y:00009B                   DC      CLK3|$0000000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for trans
mit delay
3010      Y:00009C Y:00009C                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3011      Y:00009D Y:00009D                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3012      Y:00009E Y:00009E                   DC      VIDEO+$000000+%0011001            ; Stop Integrate and sel inverting int.
3013      Y:00009F Y:00009F                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi -- charge d
ump
3014   
3015                                                                                    ;SW going low here suggests that no charge w
ill leak over OG barrier onto sense node.
3016      Y:0000A0 Y:0000A0                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3017      Y:0000A1 Y:0000A1                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3018      Y:0000A2 Y:0000A2                   DC      VIDEO+$000000+%0011001            ; StopIntegrator
3019      Y:0000A3 Y:0000A3                   DC      VIDEO+DCRST_DELAY+%0111001        ; ADCLatch,NonInv  ;mF to do ADC sampling be
fore resetting
3020   
3021                                ;  DC  CLK3|POST_SET_DLY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL ;SW->lo
3022   
3023                                END_SERIAL_IDLE_RIGHT_NO_POL
3024   
3025                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
3026                                SERIAL_IDLE_SPLIT
3027      Y:0000A4 Y:0000A4                   DC      END_SERIAL_IDLE_SPLIT-SERIAL_IDLE_SPLIT-1
3028      Y:0000A5 Y:0000A5                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3029   
3030                                ; split read version:
3031      Y:0000A6 Y:0000A6                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 53



3032   
3033                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3034                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3035                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3036                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3037                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3038   
3039      Y:0000A7 Y:0000A7                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2L|H1_3H|H2_1H|H2_2L|H2_3L|WL|TH ;h2->hi
3040      Y:0000A8 Y:0000A8                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3H|H2_1H|H2_2H|H2_3L|WL|TH ;h1->lo
3041      Y:0000A9 Y:0000A9                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3L|H2_1L|H2_2H|H2_3L|WL|TH ;h3->hi
3042      Y:0000AA Y:0000AA                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2H|H1_3L|H2_1L|H2_2H|H2_3H|WL|TH ;h2->lo
3043      Y:0000AB Y:0000AB                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2L|H1_3L|H2_1L|H2_2L|H2_3H|WL|TH ;h1->hi
3044   
3045   
3046      Y:0000AC Y:0000AC                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3047   
3048      Y:0000AD Y:0000AD                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for transmit 
delay
3049      Y:0000AE Y:0000AE                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3050      Y:0000AF Y:0000AF                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3051      Y:0000B0 Y:0000B0                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
3052      Y:0000B1 Y:0000B1                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3053      Y:0000B2 Y:0000B2                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3054      Y:0000B3 Y:0000B3                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
3055      Y:0000B4 Y:0000B4                   DC      VIDEO+$000000+%0010001            ; StopIntegrator
3056      Y:0000B5 Y:0000B5                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampling be
fore resetting
3057                                END_SERIAL_IDLE_SPLIT
3058   
3059                                ; ARC47:  |xfer|A/D|integ|polarity|not used|not used|rst| (1 => switch open)
3060                                SERIAL_IDLE_SPLIT_NO_POL
3061      Y:0000B6 Y:0000B6                   DC      END_SERIAL_IDLE_SPLIT_NO_POL-SERIAL_IDLE_SPLIT_NO_POL-1
3062      Y:0000B7 Y:0000B7                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3063   
3064                                ; split read version:
3065      Y:0000B8 Y:0000B8                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3066      Y:0000B9 Y:0000B9                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3067      Y:0000BA Y:0000BA                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3068      Y:0000BB Y:0000BB                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3069      Y:0000BC Y:0000BC                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3070      Y:0000BD Y:0000BD                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3071      Y:0000BE Y:0000BE                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3072   
3073      Y:0000BF Y:0000BF                   DC      CLK3|$000000|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;dummy for transmit 
delay
3074      Y:0000C0 Y:0000C0                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3075      Y:0000C1 Y:0000C1                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3076      Y:0000C2 Y:0000C2                   DC      VIDEO+$000000+%0011001            ; Stop Integrate and sel inverting int.
3077      Y:0000C3 Y:0000C3                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3078      Y:0000C4 Y:0000C4                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3079      Y:0000C5 Y:0000C5                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3080      Y:0000C6 Y:0000C6                   DC      VIDEO+$000000+%0011001            ; StopIntegrator
3081      Y:0000C7 Y:0000C7                   DC      VIDEO+DCRST_DELAY+%0111001        ; ADCLatch,NonInv  ;mF to do ADC sampling be
fore resetting
3082                                END_SERIAL_IDLE_SPLIT_NO_POL
3083   
3084   
3085                                ;start binning waveforms
3086                                CCD_RESET                                           ;Used for binning only
3087      Y:0000C8 Y:0000C8                   DC      END_CCD_RESET-CCD_RESET-1
3088                                END_CCD_RESET
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 54



3089   
3090                                SERIAL_CLOCK_L                                      ;"NORMAL" clocking
3091      Y:0000C9 Y:0000C9                   DC      END_SERIAL_CLOCK_L-SERIAL_CLOCK_L-1
3092      Y:0000CA Y:0000CA                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3093      Y:0000CB Y:0000CB                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3094      Y:0000CC Y:0000CC                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3095      Y:0000CD Y:0000CD                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3096      Y:0000CE Y:0000CE                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3097      Y:0000CF Y:0000CF                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3098      Y:0000D0 Y:0000D0                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3099      Y:0000D1 Y:0000D1                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3100                                END_SERIAL_CLOCK_L
3101   
3102                                SERIAL_CLOCK_R                                      ;"REVERSE" clocking
3103      Y:0000D2 Y:0000D2                   DC      END_SERIAL_CLOCK_R-SERIAL_CLOCK_R-1
3104      Y:0000D3 Y:0000D3                   DC      VIDEO+$000000+%1011000            ; NonInv,DCRestore,StrtRstInt.
3105      Y:0000D4 Y:0000D4                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3106      Y:0000D5 Y:0000D5                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h2->hi
3107      Y:0000D6 Y:0000D6                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h1->lo
3108      Y:0000D7 Y:0000D7                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3109      Y:0000D8 Y:0000D8                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h2->lo
3110      Y:0000D9 Y:0000D9                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h1->hi
3111      Y:0000DA Y:0000DA                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3112                                END_SERIAL_CLOCK_R
3113   
3114                                SERIAL_CLOCK_SPLIT                                  ;"SPLIT" clocking
3115      Y:0000DB Y:0000DB                   DC      END_SERIAL_CLOCK_SPLIT-SERIAL_CLOCK_SPLIT-1
3116      Y:0000DC Y:0000DC                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3117      Y:0000DD Y:0000DD                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3118      Y:0000DE Y:0000DE                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3119      Y:0000DF Y:0000DF                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3120      Y:0000E0 Y:0000E0                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3121      Y:0000E1 Y:0000E1                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3122      Y:0000E2 Y:0000E2                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3123      Y:0000E3 Y:0000E3                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3124                                END_SERIAL_CLOCK_SPLIT
3125   
3126   
3127                                VIDEO_PROCESS
3128      Y:0000E4 Y:0000E4                   DC      END_VIDEO_PROCESS-VIDEO_PROCESS-1
3129                                ;SXMIT  DC  $00F000     ; Transmit A/D data to host
3130      Y:0000E5 Y:0000E5                   DC      VIDEO+$000000+%1011000            ; StopDCRestore and StopResetIntegrator
3131      Y:0000E6 Y:0000E6                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3132      Y:0000E7 Y:0000E7                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
3133      Y:0000E8 Y:0000E8                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3134      Y:0000E9 Y:0000E9                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3135      Y:0000EA Y:0000EA                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
3136      Y:0000EB Y:0000EB                   DC      VIDEO+$000000+%0010001            ; StopResetIntegrator
3137      Y:0000EC Y:0000EC                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampeling b
evore resetting
3138                                END_VIDEO_PROCESS
3139                                ;end binning waveforms
3140   
3141   
3142                                ; Video processor bit definition
3143                                ;      xfer, A/D, integ, Pol+, Pol-, DCrestore, rst   (1 => switch open)
3144   
3145                                ; These are the three reading tables. Make sure they're all the same length
3146                                ; 2->3->1->2
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 55



3147                                SERIAL_READ_LEFT
3148      Y:0000ED Y:0000ED                   DC      END_SERIAL_READ_LEFT-SERIAL_READ_LEFT-1
3149      Y:0000EE Y:0000EE                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3150      Y:0000EF Y:0000EF                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3151      Y:0000F0 Y:0000F0                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3152      Y:0000F1 Y:0000F1                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3153      Y:0000F2 Y:0000F2                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3154      Y:0000F3 Y:0000F3                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3155      Y:0000F4 Y:0000F4                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3156      Y:0000F5 Y:0000F5                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3157      Y:0000F6 Y:0000F6         SXL       DC      $00F000                           ;Transmit a/d data to host
3158      Y:0000F7 Y:0000F7                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3159      Y:0000F8 Y:0000F8                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3160      Y:0000F9 Y:0000F9                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
3161      Y:0000FA Y:0000FA                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3162      Y:0000FB Y:0000FB                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3163      Y:0000FC Y:0000FC                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
3164      Y:0000FD Y:0000FD                   DC      VIDEO+$000000+%0010001            ; StopResetIntegrator
3165      Y:0000FE Y:0000FE                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampeling b
evore resetting
3166                                END_SERIAL_READ_LEFT
3167   
3168   
3169                                ;SERIAL_READ_SPLIT
3170                                ;  DC  END_SERIAL_READ_SPLIT-SERIAL_READ_SPLIT-1
3171                                ;  DC  VIDEO+$000000+%1011000  ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3172                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset_On
3173                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3174                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3175                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3176                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3177                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
3178                                ;  DC  CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3179                                ;SXRL  DC  $00F040     ;Transmit a/d data to host
3180                                ;  DC  VIDEO+$000000+%0011001  ; StopDCRestore and StopResetIntegrator
3181                                ;  DC  VIDEO+I_DELAY+%0001001  ; Integrate for I_DELAY microsec
3182                                ;  DC  VIDEO+$000000+%0010001  ; Stop Integrate and sel inverting int.
3183                                ;  DC  CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3184                                ;  DC  CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3185                                ;  DC  VIDEO+I_DELAY+%0000001  ; Integrate for I_DELAY microsec
3186                                ;  DC  VIDEO+$000000+%0010001  ; StopResetIntegrator
3187                                ;  DC  VIDEO+DCRST_DELAY+%0110001  ; ADCLatch,NonInv  ;mF to do ADC sampeling bevore resetting
3188                                ;END_SERIAL_READ_SPLIT
3189   
3190                                SERIAL_READ_SPLIT
3191      Y:0000FF Y:0000FF                   DC      END_SERIAL_READ_SPLIT-SERIAL_READ_SPLIT-1
3192      Y:000100 Y:000100                   DC      VIDEO+$000000+%1011000            ; ADCLatch,NonInv,DCRestore,StrtRstInt.
3193      Y:000101 Y:000101                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2L|H1_3H|H2_1H|H2_2L|H2_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3194   
3195      Y:000102 Y:000102                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2L|H1_3H|H2_1H|H2_2L|H2_3L|WL|TH ;h2->hi
3196      Y:000103 Y:000103                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3H|H2_1H|H2_2H|H2_3L|WL|TH ;h1->lo
3197      Y:000104 Y:000104                   DC      CLK3|S_DELAY|RH|H1_1L|H1_2H|H1_3L|H2_1L|H2_2H|H2_3L|WL|TH ;h3->hi
3198      Y:000105 Y:000105                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2H|H1_3L|H2_1L|H2_2H|H2_3H|WL|TH ;h2->lo
3199      Y:000106 Y:000106                   DC      CLK3|S_DELAY|RH|H1_1H|H1_2L|H1_3L|H2_1L|H2_2L|H2_3H|WL|TH ;h1->hi
3200   
3201                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3202                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3203                                ;  DC  CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3204                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3205                                ;  DC  CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 56



3206   
3207   
3208      Y:000107 Y:000107                   DC      CLK3|PRE_SET_DLY|RL|H1_1H|H1_2L|H1_3H|H2_1H|H2_2L|H2_3H|WL|TH ;Reset_Off|Delay
3209      Y:000108 Y:000108         SXRL      DC      $00F0C2                           ;Transmit a/d data to host
3210      Y:000109 Y:000109                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3211      Y:00010A Y:00010A                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3212      Y:00010B Y:00010B                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
3213      Y:00010C Y:00010C                   DC      CLK3|SW_DELAY|RL|H1_1H|H1_2L|H1_3H|H2_1H|H2_2L|H2_3H|WH|TH ;SW->hi
3214      Y:00010D Y:00010D                   DC      CLK3|POST_SET_DLY|RL|H1_1H|H1_2L|H1_3H|H2_1H|H2_2L|H2_3H|WL|TH ;SW->lo
3215      Y:00010E Y:00010E                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
3216      Y:00010F Y:00010F                   DC      VIDEO+$000000+%0010001            ; StopResetIntegrator
3217      Y:000110 Y:000110                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampeling b
evore resetting
3218                                END_SERIAL_READ_SPLIT
3219   
3220                                ; 2->1->3->2
3221                                SERIAL_READ_RIGHT
3222      Y:000111 Y:000111                   DC      END_SERIAL_READ_RIGHT-SERIAL_READ_RIGHT-1
3223      Y:000112 Y:000112                   DC      VIDEO+$000000+%1011000            ; NonInv,DCRestore,StrtRstInt.
3224      Y:000113 Y:000113                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;h3->lo,SW->lo,Reset
_On
3225      Y:000114 Y:000114                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h2->hi
3226      Y:000115 Y:000115                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h1->lo
3227      Y:000116 Y:000116                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3228      Y:000117 Y:000117                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h2->lo
3229      Y:000118 Y:000118                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h1->hi
3230      Y:000119 Y:000119                   DC      CLK3|PRE_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3231      Y:00011A Y:00011A         SXR       DC      $00F041                           ;Transmit a/d data to host
3232      Y:00011B Y:00011B                   DC      VIDEO+$000000+%0011001            ; StopDCRestore and StopResetIntegrator
3233      Y:00011C Y:00011C                   DC      VIDEO+I_DELAY+%0001001            ; Integrate for I_DELAY microsec
3234      Y:00011D Y:00011D                   DC      VIDEO+$000000+%0010001            ; Stop Integrate and sel inverting int.
3235      Y:00011E Y:00011E                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3236      Y:00011F Y:00011F                   DC      CLK3|POST_SET_DLY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;SW->lo
3237      Y:000120 Y:000120                   DC      VIDEO+I_DELAY+%0000001            ; Integrate for I_DELAY microsec
3238      Y:000121 Y:000121                   DC      VIDEO+$000000+%0010001            ; StopIntegrator
3239      Y:000122 Y:000122                   DC      VIDEO+DCRST_DELAY+%0110001        ; ADCLatch,NonInv  ;mF to do ADC sampeling b
efore resetting
3240                                END_SERIAL_READ_RIGHT
3241   
3242   
3243                                ; These are the three skipping tables. Make sure they're all the same length
3244                                SERIAL_SKIP_LEFT                                    ; Serial clocking waveform for skipping left
3245      Y:000123 Y:000123                   DC      END_SERIAL_SKIP_LEFT-SERIAL_SKIP_LEFT-1
3246      Y:000124 Y:000124                   DC      VIDEO+$000000+%1011000            ; Change nearly everything
3247      Y:000125 Y:000125                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h2->hi
3248      Y:000126 Y:000126                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h1->lo
3249      Y:000127 Y:000127                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3250      Y:000128 Y:000128                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h2->lo
3251      Y:000129 Y:000129                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h1->hi
3252      Y:00012A Y:00012A                   DC      CLK3|S_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3253      Y:00012B Y:00012B                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3254                                END_SERIAL_SKIP_LEFT
3255   
3256                                SERIAL_SKIP_RIGHT                                   ; Serial clocking waveform for skipping righ
t
3257      Y:00012C Y:00012C                   DC      END_SERIAL_SKIP_RIGHT-SERIAL_SKIP_RIGHT-1
3258      Y:00012D Y:00012D                   DC      VIDEO+$000000+%1011000            ; Change nearly everything
3259      Y:00012E Y:00012E                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1H|H1_2L|H1_3L|WL|TH ;h2->hi
3260      Y:00012F Y:00012F                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1H|H1_2H|H1_3L|WL|TH ;h1->lo
3261      Y:000130 Y:000130                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3262      Y:000131 Y:000131                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1L|H1_2H|H1_3H|WL|TH ;h2->lo
3263      Y:000132 Y:000132                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1L|H1_2L|H1_3H|WL|TH ;h1->hi
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 57



3264      Y:000133 Y:000133                   DC      CLK3|S_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3265      Y:000134 Y:000134                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3266                                END_SERIAL_SKIP_RIGHT
3267   
3268                                SERIAL_SKIP_SPLIT                                   ; Serial clocking waveform for skipping both
 ends
3269      Y:000135 Y:000135                   DC      END_SERIAL_SKIP_SPLIT-SERIAL_SKIP_SPLIT-1
3270      Y:000136 Y:000136                   DC      VIDEO+$000000+%1011000            ; Change nearly everything
3271      Y:000137 Y:000137                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2L|H2_3L|H1_1L|H1_2L|H1_3H|WL|TH ;h2->hi
3272      Y:000138 Y:000138                   DC      CLK3|S_DELAY|RH|H2_1H|H2_2H|H2_3L|H1_1L|H1_2H|H1_3H|WL|TH ;h1->lo
3273      Y:000139 Y:000139                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3L|H1_1L|H1_2H|H1_3L|WL|TH ;h3->hi
3274      Y:00013A Y:00013A                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2H|H2_3H|H1_1H|H1_2H|H1_3L|WL|TH ;h2->lo
3275      Y:00013B Y:00013B                   DC      CLK3|S_DELAY|RH|H2_1L|H2_2L|H2_3H|H1_1H|H1_2L|H1_3L|WL|TH ;h1->hi
3276      Y:00013C Y:00013C                   DC      CLK3|S_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WL|TH ;Reset_Off|Delay
3277      Y:00013D Y:00013D                   DC      CLK3|SW_DELAY|RL|H2_1H|H2_2L|H2_3H|H1_1H|H1_2L|H1_3H|WH|TH ;SW->hi
3278                                END_SERIAL_SKIP_SPLIT
3279   
3281                                ; ORG Y:$1C0,Y:$1C0   ; Download address
3283                                VSUBN
3284                                          VOLTS   VSUB,45.0                         ; Vsub  0.0 140 V, pin #
**** 3289 [sg2.waveforms.reverse 820]: Setting voltage VSUB 45.0V 23043082496
3290      Y:00013F Y:00013F         ERHI      DC      ERHI_END-ERHI-1
3291                                          VOLTS   VSUB,0                            ; Vsub  0.0 140 V, pin #
**** 3296 [sg2.waveforms.reverse 822]: Setting voltage VSUB 0V 03080192
3297                                ; VOLTS V1_HI,9   ; Vertical High
3298                                ; VOLTS V1_LO,9   ; Vertical Low
3299                                ; VOLTS V2_HI,9   ; Vertical High
3300                                ; VOLTS V2_LO,9   ; Vertical Low
3301                                ; VOLTS V3_HI,9   ; Vertical High
3302                                ; VOLTS V3_LO,9   ; Vertical Low
3303                                ; VOLTS FS1_HI,9    ; Vertical High
3304                                ; VOLTS FS1_LO,9    ; Vertical Low
3305                                ; VOLTS FS2_HI,9    ; Vertical High
3306                                ; VOLTS FS2_LO,9    ; Vertical Low
3307                                ; VOLTS FS3_HI,9    ; Vertical High
3308                                ; VOLTS FS3_LO,9    ; Vertical Low
3309      Y:000141 Y:000141                   DC      $200100+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #1, Vertical Clock 1
3310      Y:000142 Y:000142                   DC      $200200+@CVI((9+Vmax)/(2*Vmax)*255)
3311      Y:000143 Y:000143                   DC      $200400+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #2, Vertical Clock 2
3312      Y:000144 Y:000144                   DC      $200800+@CVI((9+Vmax)/(2*Vmax)*255)
3313      Y:000145 Y:000145                   DC      $202000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #3, Vertical Clock 3
3314      Y:000146 Y:000146                   DC      $204000+@CVI((9+Vmax)/(2*Vmax)*255)
3315      Y:000147 Y:000147                   DC      $208000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #4, Frame Store 1
3316      Y:000148 Y:000148                   DC      $210000+@CVI((9+Vmax)/(2*Vmax)*255)
3317      Y:000149 Y:000149                   DC      $220100+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #5, Frame Store 2
3318      Y:00014A Y:00014A                   DC      $220200+@CVI((9+Vmax)/(2*Vmax)*255)
3319      Y:00014B Y:00014B                   DC      $220400+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #6, Frame Store 3
3320      Y:00014C Y:00014C                   DC      $220800+@CVI((9+Vmax)/(2*Vmax)*255)
3321      Y:00014D Y:00014D                   DC      $222000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #7, Transfer Gate 2
3322      Y:00014E Y:00014E                   DC      $224000+@CVI((9+Vmax)/(2*Vmax)*255)
3323      Y:00014F Y:00014F                   DC      $228000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #8, Transger Gate 1
3324      Y:000150 Y:000150                   DC      $230000+@CVI((9+Vmax)/(2*Vmax)*255)
3325      Y:000151 Y:000151                   DC      $240100+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #9, Unused
3326      Y:000152 Y:000152                   DC      $240200+@CVI((9+Vmax)/(2*Vmax)*255)
3327      Y:000153 Y:000153                   DC      $240400+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #10, Unused
3328      Y:000154 Y:000154                   DC      $240800+@CVI((9+Vmax)/(2*Vmax)*255)
3329      Y:000155 Y:000155                   DC      $242000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
3330      Y:000156 Y:000156                   DC      $244000+@CVI((9+Vmax)/(2*Vmax)*255)
3331      Y:000157 Y:000157                   DC      $248000+@CVI((9+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
3332      Y:000158 Y:000158                   DC      $250000+@CVI((9+Vmax)/(2*Vmax)*255)
3333      Y:000159 Y:000159         ERHI_END  DC      EPUR-ERHI_END-1
3334                                ; VOLTS V1_HI,5.0 ; Vertical High
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 58



3335                                ; VOLTS V1_LO,-3.0  ; Vertical Low
3336                                ; VOLTS V2_HI,5.0 ; Vertical High
3337                                ; VOLTS V2_LO,-3.0  ; Vertical Low
3338                                ; VOLTS V3_HI,5.0 ; Vertical High
3339                                ; VOLTS V3_LO,-3.0  ; Vertical Low
3340                                ; VOLTS FS1_HI,5.0  ; Vertical High
3341                                ; VOLTS FS1_LO,-3.0 ; Vertical Low
3342                                ; VOLTS FS2_HI,5.0  ; Vertical High
3343                                ; VOLTS FS2_LO,-3.0 ; Vertical Low
3344                                ; VOLTS FS3_HI,5.0  ; Vertical High
3345                                ; VOLTS FS3_LO,-3.0 ; Vertical Low
3346                                ;Return to normal voltages
3347      Y:00015A Y:00015A                   DC      $200100+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #1, Vertical Clock 1
3348      Y:00015B Y:00015B                   DC      $200200+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3349      Y:00015C Y:00015C                   DC      $200400+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #2, Vertical Clock 2
3350      Y:00015D Y:00015D                   DC      $200800+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3351      Y:00015E Y:00015E                   DC      $202000+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #3, Vertical Clock 3
3352      Y:00015F Y:00015F                   DC      $204000+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3353      Y:000160 Y:000160                   DC      $208000+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #4, Frame Store 1
3354      Y:000161 Y:000161                   DC      $210000+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3355      Y:000162 Y:000162                   DC      $220100+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #5, Frame Store 2
3356      Y:000163 Y:000163                   DC      $220200+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3357      Y:000164 Y:000164                   DC      $220400+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #6, Frame Store 3
3358      Y:000165 Y:000165                   DC      $220800+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3359      Y:000166 Y:000166                   DC      $222000+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #7, Transfer Gate 2
3360      Y:000167 Y:000167                   DC      $224000+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3361      Y:000168 Y:000168                   DC      $228000+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #8, Transger Gate 1
3362      Y:000169 Y:000169                   DC      $230000+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3363      Y:00016A Y:00016A                   DC      $240100+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #9, Unused
3364      Y:00016B Y:00016B                   DC      $240200+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3365      Y:00016C Y:00016C                   DC      $240400+@CVI((FS1_HI+Vmax)/(2*Vmax)*255) ; Pin #10, Unused
3366      Y:00016D Y:00016D                   DC      $240800+@CVI((FS1_LO+Vmax)/(2*Vmax)*255)
3367      Y:00016E Y:00016E                   DC      $242000+@CVI((FS2_HI+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
3368      Y:00016F Y:00016F                   DC      $244000+@CVI((FS2_LO+Vmax)/(2*Vmax)*255)
3369      Y:000170 Y:000170                   DC      $248000+@CVI((FS3_HI+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
3370      Y:000171 Y:000171                   DC      $250000+@CVI((FS3_LO+Vmax)/(2*Vmax)*255)
3371   
3372      Y:000172 Y:000172                   DC      $2A0100+@CVI((RL_HI+Vmax)/(2*Vmax)*255) ; Pin #34, Reset Gate Upper
3373      Y:000173 Y:000173                   DC      $2A0200+@CVI((RL_LO+Vmax)/(2*Vmax)*255)
3374      Y:000174 Y:000174                   DC      $2A0400+@CVI((RU_HI+Vmax)/(2*Vmax)*255) ; Pin #35, Reset Gate Lower
3375      Y:000175 Y:000175                   DC      $2A0800+@CVI((RU_LO+Vmax)/(2*Vmax)*255)
3376   
3377      Y:000176 Y:000176         EPUR      DC      EPUR_END-EPUR-1
3378      Y:000177 Y:000177                   DC      $200100+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #1, Vertical Clock 1
3379      Y:000178 Y:000178                   DC      $200200+@CVI((-9+Vmax)/(2*Vmax)*255)
3380      Y:000179 Y:000179                   DC      $200400+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #2, Vertical Clock 2
3381      Y:00017A Y:00017A                   DC      $200800+@CVI((-9+Vmax)/(2*Vmax)*255)
3382      Y:00017B Y:00017B                   DC      $202000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #3, Vertical Clock 3
3383      Y:00017C Y:00017C                   DC      $204000+@CVI((-9+Vmax)/(2*Vmax)*255)
3384      Y:00017D Y:00017D                   DC      $208000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #4, Frame Store 1
3385      Y:00017E Y:00017E                   DC      $210000+@CVI((-9+Vmax)/(2*Vmax)*255)
3386      Y:00017F Y:00017F                   DC      $220100+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #5, Frame Store 2
3387      Y:000180 Y:000180                   DC      $220200+@CVI((-9+Vmax)/(2*Vmax)*255)
3388      Y:000181 Y:000181                   DC      $220400+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #6, Frame Store 3
3389      Y:000182 Y:000182                   DC      $220800+@CVI((-9+Vmax)/(2*Vmax)*255)
3390      Y:000183 Y:000183                   DC      $222000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #7, Transfer Gate 2
3391      Y:000184 Y:000184                   DC      $224000+@CVI((-9+Vmax)/(2*Vmax)*255)
3392      Y:000185 Y:000185                   DC      $228000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #8, Transger Gate 1
3393      Y:000186 Y:000186                   DC      $230000+@CVI((-9+Vmax)/(2*Vmax)*255)
3394      Y:000187 Y:000187                   DC      $240100+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #9, Unused
3395      Y:000188 Y:000188                   DC      $240200+@CVI((-9+Vmax)/(2*Vmax)*255)
3396      Y:000189 Y:000189                   DC      $240400+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #10, Unused
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 59



3397      Y:00018A Y:00018A                   DC      $240800+@CVI((-9+Vmax)/(2*Vmax)*255)
3398      Y:00018B Y:00018B                   DC      $242000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
3399      Y:00018C Y:00018C                   DC      $244000+@CVI((-9+Vmax)/(2*Vmax)*255)
3400      Y:00018D Y:00018D                   DC      $248000+@CVI((-9+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
3401      Y:00018E Y:00018E                   DC      $250000+@CVI((-9+Vmax)/(2*Vmax)*255)
3402   
3403      Y:00018F Y:00018F                   DC      $2A0100+@CVI((-6+Vmax)/(2*Vmax)*255) ; Pin #34, Reset Gate Upper
3404      Y:000190 Y:000190                   DC      $2A0200+@CVI((-6+Vmax)/(2*Vmax)*255)
3405      Y:000191 Y:000191                   DC      $2A0400+@CVI((-6+Vmax)/(2*Vmax)*255) ; Pin #35, Reset Gate Lower
3406      Y:000192 Y:000192                   DC      $2A0800+@CVI((-6+Vmax)/(2*Vmax)*255)
3407   
3408                                EPUR_END
3409   
3410                                ; Code for ARC32 = universal clock driver board
3411      Y:000193 Y:000193         DACS      DC      END_DACS-DACS-1
3412      Y:000194 Y:000194                   DC      $2A0080                           ; DAC = unbuffered mode
3413   
3414      Y:000195 Y:000195                   DC      $200100+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #1, Vertical Clock 1
3415      Y:000196 Y:000196                   DC      $200200+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3416      Y:000197 Y:000197                   DC      $200400+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #2, Vertical Clock 2
3417      Y:000198 Y:000198                   DC      $200800+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3418      Y:000199 Y:000199                   DC      $202000+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #3, Vertical Clock 3
3419      Y:00019A Y:00019A                   DC      $204000+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3420      Y:00019B Y:00019B                   DC      $208000+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #4, Frame Store 1
3421      Y:00019C Y:00019C                   DC      $210000+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3422      Y:00019D Y:00019D                   DC      $220100+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #5, Frame Store 2
3423      Y:00019E Y:00019E                   DC      $220200+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3424      Y:00019F Y:00019F                   DC      $220400+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #6, Frame Store 3
3425      Y:0001A0 Y:0001A0                   DC      $220800+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3426      Y:0001A1 Y:0001A1                   DC      $222000+@CVI((V1_HI+Vmax)/(2*Vmax)*255) ; Pin #7, Transfer Gate 2
3427      Y:0001A2 Y:0001A2                   DC      $224000+@CVI((V1_LO+Vmax)/(2*Vmax)*255)
3428      Y:0001A3 Y:0001A3                   DC      $228000+@CVI((V2_HI+Vmax)/(2*Vmax)*255) ; Pin #8, Transger Gate 1
3429      Y:0001A4 Y:0001A4                   DC      $230000+@CVI((V2_LO+Vmax)/(2*Vmax)*255)
3430   
3431      Y:0001A5 Y:0001A5                   DC      $240100+@CVI((V3_HI+Vmax)/(2*Vmax)*255) ; Pin #9, Unused
3432      Y:0001A6 Y:0001A6                   DC      $240200+@CVI((V3_LO+Vmax)/(2*Vmax)*255)
3433      Y:0001A7 Y:0001A7                   DC      $240400+@CVI((FS1_HI+Vmax)/(2*Vmax)*255) ; Pin #10, Unused
3434      Y:0001A8 Y:0001A8                   DC      $240800+@CVI((FS1_LO+Vmax)/(2*Vmax)*255)
3435      Y:0001A9 Y:0001A9                   DC      $242000+@CVI((FS2_HI+Vmax)/(2*Vmax)*255) ; Pin #11, Unused
3436      Y:0001AA Y:0001AA                   DC      $244000+@CVI((FS2_LO+Vmax)/(2*Vmax)*255)
3437      Y:0001AB Y:0001AB                   DC      $248000+@CVI((FS3_HI+Vmax)/(2*Vmax)*255) ; Pin #12, Unused
3438      Y:0001AC Y:0001AC                   DC      $250000+@CVI((FS3_LO+Vmax)/(2*Vmax)*255)
3439   
3440      Y:0001AD Y:0001AD                   DC      $260100+@CVI((H1U2_L1_HI+Vmax)/(2*Vmax)*255) ; Pin #13, Horizontal 1 Upper
3441      Y:0001AE Y:0001AE                   DC      $260200+@CVI((H1U2_L1_LO+Vmax)/(2*Vmax)*255)
3442      Y:0001AF Y:0001AF                   DC      $260400+@CVI((H2U2_L1_HI+Vmax)/(2*Vmax)*255) ; Pin #14, Horizontal 2 Upper
3443      Y:0001B0 Y:0001B0                   DC      $260800+@CVI((H2U2_L1_LO+Vmax)/(2*Vmax)*255)
3444      Y:0001B1 Y:0001B1                   DC      $262000+@CVI((H3U2_L1_HI+Vmax)/(2*Vmax)*255) ; Pin #15, Horizontal 3 Upper
3445      Y:0001B2 Y:0001B2                   DC      $264000+@CVI((H3U2_L1_LO+Vmax)/(2*Vmax)*255)
3446      Y:0001B3 Y:0001B3                   DC      $268000+@CVI((H1U1_L2_HI+Vmax)/(2*Vmax)*255) ; Pin #16, Horizontal 1 Lower
3447      Y:0001B4 Y:0001B4                   DC      $270000+@CVI((H1U1_L2_LO+Vmax)/(2*Vmax)*255)
3448      Y:0001B5 Y:0001B5                   DC      $280100+@CVI((H2U1_L2_HI+Vmax)/(2*Vmax)*255) ; Pin #17, Horizontal 2 Lower
3449      Y:0001B6 Y:0001B6                   DC      $280200+@CVI((H2U1_L2_LO+Vmax)/(2*Vmax)*255)
3450      Y:0001B7 Y:0001B7                   DC      $280400+@CVI((H3U1_L2_HI+Vmax)/(2*Vmax)*255) ; Pin #18, Horizontal 3 Lower
3451      Y:0001B8 Y:0001B8                   DC      $280800+@CVI((H3U1_L2_LO+Vmax)/(2*Vmax)*255)
3452      Y:0001B9 Y:0001B9                   DC      $282000+@CVI((SWL_HI+Vmax)/(2*Vmax)*255) ; Pin #19, Summing Well Upper
3453      Y:0001BA Y:0001BA                   DC      $284000+@CVI((SWL_LO+Vmax)/(2*Vmax)*255)
3454      Y:0001BB Y:0001BB                   DC      $288000+@CVI((SWU_HI+Vmax)/(2*Vmax)*255) ; Pin #33, Summing Well Lower
3455      Y:0001BC Y:0001BC                   DC      $290000+@CVI((SWU_LO+Vmax)/(2*Vmax)*255)
3456      Y:0001BD Y:0001BD                   DC      $2A0100+@CVI((RL_HI+Vmax)/(2*Vmax)*255) ; Pin #34, Reset Gate Upper
3457      Y:0001BE Y:0001BE                   DC      $2A0200+@CVI((RL_LO+Vmax)/(2*Vmax)*255)
3458      Y:0001BF Y:0001BF                   DC      $2A0400+@CVI((RU_HI+Vmax)/(2*Vmax)*255) ; Pin #35, Reset Gate Lower
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 60



3459      Y:0001C0 Y:0001C0                   DC      $2A0800+@CVI((RU_LO+Vmax)/(2*Vmax)*255)
3460      Y:0001C1 Y:0001C1                   DC      $2A2000+@CVI((T1_HI+Vmax)/(2*Vmax)*255) ; Pin #36, Unused
3461      Y:0001C2 Y:0001C2                   DC      $2A4000+@CVI((T1_LO+Vmax)/(2*Vmax)*255)
3462      Y:0001C3 Y:0001C3                   DC      $2A8000+@CVI((T2_HI+Vmax)/(2*Vmax)*255) ; Pin #37, Unused
3463      Y:0001C4 Y:0001C4                   DC      $2B0000+@CVI((T2_LO+Vmax)/(2*Vmax)*255)
3464   
3465   
3466                                ; DC bias voltages for the LBL CCD chip
3467                                          VOLTS   VSUB,45.0                         ; Vsub  0.0 140 V
**** 3472 [sg2.waveforms.reverse 993]: Setting voltage VSUB 45.0V 23043082496
3473                                          VOLTS   RAMP,5.0                          ; Vsub  AVG RAMP RATE
**** 3478 [sg2.waveforms.reverse 994]: Setting voltage RAMP 5.0V 20483098624
3479                                          VOLTS   VDDL2,-22.0                       ; Vdd  -5.1 -25V
**** 3484 [sg2.waveforms.reverse 995]: Setting voltage VDDL2 -22.0V 36042887188
3485                                          VOLTS   VDDU2,-22.0                       ; Vdd  -5.1 -25V
**** 3490 [sg2.waveforms.reverse 996]: Setting voltage VDDU2 -22.0V 36042903572
3491                                          VOLTS   VDDL1,-22.0                       ; Vdd  -5.1 -25V
**** 3496 [sg2.waveforms.reverse 997]: Setting voltage VDDL1 -22.0V 36042919956
3497                                          VOLTS   VDDU1,-22.0                       ; Vdd  -5.1 -25V
**** 3502 [sg2.waveforms.reverse 998]: Setting voltage VDDU1 -22.0V 36042936340
3503                                          VOLTS   VRL2,-12.5                        ; Vr   -5.1 -25V
**** 3508 [sg2.waveforms.reverse 999]: Setting voltage VRL2 -12.5V 20482951168
3509                                          VOLTS   VRU2,-12.5                        ; Vr   -5.1 -25V
**** 3514 [sg2.waveforms.reverse 1000]: Setting voltage VRU2 -12.5V 20482967552
3515                                          VOLTS   VRL1,-12.5                        ; Vr   -5.1 -25V
**** 3520 [sg2.waveforms.reverse 1001]: Setting voltage VRL1 -12.5V 20482983936
3521                                          VOLTS   VRU1,-12.5                        ; Vr   -5.1 -25V
**** 3526 [sg2.waveforms.reverse 1002]: Setting voltage VRU1 -12.5V 20483000320
3527                                          VOLTS   VOGL2,4.00                        ; Vopg  -10  10 V
**** 3532 [sg2.waveforms.reverse 1003]: Setting voltage VOGL2 4.00V 32763017932
3533                                          VOLTS   VOGU2,2.50                        ; Vopg  -10  10 V
**** 3538 [sg2.waveforms.reverse 1004]: Setting voltage VOGU2 2.50V 20483033088
3539                                          VOLTS   VOGL1,2.50                        ; Vopg  -10  10 V
**** 3544 [sg2.waveforms.reverse 1005]: Setting voltage VOGL1 2.50V 20483049472
3545                                          VOLTS   VOGU1,2.50                        ; Vopg  -10  10 V
**** 3550 [sg2.waveforms.reverse 1006]: Setting voltage VOGU1 2.50V 20483065856
3551   
3552   
3553                                 GAIN_SETTING
3554      Y:0001D3 Y:0001D3                   DC      VID0+$0D000E                      ; Gain of 1.25 (from 0 to $F,one of 16 possi
ble values)
3555   
3556                                ;Initialize the ARC-47 DAC for video offsets, board #0
3557      Y:0001D4 Y:0001D4                   DC      VID0+DAC_ADDR+$000014
3558      Y:0001D5 Y:0001D5                   DC      VID0+DAC_RegD+OFFSET0
3559      Y:0001D6 Y:0001D6                   DC      VID0+DAC_ADDR+$000015
3560      Y:0001D7 Y:0001D7                   DC      VID0+DAC_RegD+OFFSET1
3561      Y:0001D8 Y:0001D8                   DC      VID0+DAC_ADDR+$000016
3562      Y:0001D9 Y:0001D9                   DC      VID0+DAC_RegD+OFFSET2
3563      Y:0001DA Y:0001DA                   DC      VID0+DAC_ADDR+$000017
3564      Y:0001DB Y:0001DB                   DC      VID0+DAC_RegD+OFFSET3
3565   
3566   
3567                                ;  DC   VID0+DAC_ADDR+$00000C           ; Vabg,pin 5
3568                                ;  DC   VID0+DAC_RegD+DAC_VRSV
3569                                ;  DC   VID0+DAC_ADDR+$00000D           ; Vrsv1,pin 47
3570                                ;  DC   VID0+DAC_RegD+DAC_VRSV
3571                                ;  DC   VID0+DAC_ADDR+$00000E           ; Vrsv2,pin 27
3572                                ;  DC   VID0+DAC_RegD+DAC_VRSV
3573                                ;  DC   VID0+DAC_ADDR+$00000F           ; Vrsv3,pin 6
3574                                ;  DC   VID0+DAC_RegD+DAC_VRSV
3575   
Motorola DSP56300 Assembler  Version 6.3.4   08-09-23  20:03:38  sg2.waveforms.reverse  Page 61



3576   
3577                                END_DACS
3578   
3579   
3580                                ; Pixel table generated in "timCCD.asm"
3581      Y:0001DC Y:0001DC         PXL_TBL   DC      0
3582   
3583   
3584   
3585                                 END_APPLICATON_Y_MEMORY
3586      0001DD                              EQU     @LCV(L)
3587   
3588   
3589                                ; End of program
3590                                          END

0    Errors
0    Warnings


